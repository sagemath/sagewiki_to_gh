= Design discussion about Hecke Algebras =

Quite a few people expressed interest in (affine) Iwahori-Hecke algebras, including
NicolasBorie, DanBump, BrantJones, VincentFeray, FlorentHivert, MikeHansen, AndrewMathas, AnneSchilling, NicolasThi√©ry.

There are pieces of code for it in many different places in MuPAD-Combinat, also a bit in Sage, etc. It is time for setting up where we want to go, and cleanup that mess!

* http://mupad-combinat.svn.sourceforge.net/viewvc/mupad-combinat/trunk/MuPAD-Combinat/lib/EXAMPLES/HeckeAlgebra.mu
* http://mupad-combinat.svn.sourceforge.net/viewvc/mupad-combinat/trunk/MuPAD-Combinat/lib/EXAMPLES/HeckeGroupAlgebra.mu
* http://mupad-combinat.svn.sourceforge.net/viewvc/mupad-combinat/trunk/MuPAD-Combinat/experimental/2006-06-27-HeckeCoxeter.mu
* http://www.mupad-combinat.svn.sourceforge.net:80/viewvc/mupad-combinat/trunk/MuPAD-Combinat/experimental/2008-02-13-HeckeSpechtModules.mu

Here is a first draft of user story describing how we would want to use this algebra. Please expand and comment!

{{{HeckeAlgebra

We construct the `(q_1,q_2)`-(Iwahori-)Hecke algebra for the Weyl
group W of type B_3. This is the algebra generated by operators `T_1,
T_2, T_3` satisfying the same braid-like relations as the simple
reflections in W, but subject to the quadratic relation `(T_i -
q_1)(T_i - q_2) = 0`.  (i.e. `q_1`, and `q_2` are the eigenvalues of
the generators `T_i`).  Different mathematicians uses different
parametrizations. This one is the most generic, and can easily be
specialized to other ones.

Of course, we need to take a base ring which contains the
parameters `q_1` and `q_2`.

    sage: W = WeylGroup(["B",3])
    sage: R = QQ['q1,q2']
    sage: q1,q2 = R.gens()
    sage: HeckeAlgebra(R, W, q1, q2)
    The (q1,q2)-Hecke algebra of the Weyl group of type B_3

The default value for the parameters give the usual normalization q1=q and q2=-1:

    sage: HeckeAlgebra(QQ['q'], W)
    The q-Hecke algebra of the Weyl group of type B_3

(note: do we want to automatically extend the field with the parameter 'q'???

The parameters can also be specialized to numbers, like roots of
unity, ... Here we construct the algebra of the symmetric group, the
zero-Hecke algebra, and the nil-Hecke algebra::

    sage: HeckeAlgebra(QQ['q'], W, q1=1)
    The 0-Hecke algebra of the Weyl group of type B_3

    sage: HeckeAlgebra(QQ['q'], W, q1=0)
    The 0-Hecke algebra of the Weyl group of type B_3

    sage: HeckeAlgebra(QQ['q'], W, q1=0,q2=0)
    The nil-Hecke algebra of the Weyl group of type B_3

Let us get back to the default::
    sage: H = HeckeAlgebra(QQ['q'], W)
    The q-Hecke algebra of the Weyl group of type B_3
    
So far, all we have been doing is constructing the abstract Hecke
algebra. To actually compute within it, one need to choose a concrete
basis where the elements will be expanded. The first basis is the T
basis: `(T_w = \prod_{i \in red(w)} T_i)_{w \in W}`::

    sage: H.T()
    The q-Hecke algebra of the Weyl group of type B_3, with elements expresses in the T basis
    sage: T = H.T().basis()
    This basis is indexed by elements of the WeylGroup:
    sage: s = W.simple_reflections(); w = s[1]*s[2]
    sage: T[w] + 3 * T[s[1]]^2

Do we want to provide the following slight abuse of notation, as a
convenience for the reader?

    sage: T[1] + 2*T[3,2,3,1]
    
which would be equivalent to:

    sage: T[s[1]] + 2 * T[s[3]+s[2]+s[3]+s[1]]


Another option is to express elements in the Yang Baxter basis, which
depends on a set of spectral parameters (aka an element of the torus
of the Lie group, or character of the root lattice).

    sage: YB = H.yang_baxter(spectral_parameters).basis()
    sage: YB[s[2]*s[1]]
    ...

One can switch back and forth between those two bases by:

    sage: H.T()( YB[3,2,3,1] + 3 )
    ...

TODO: find the appropriate shortcut syntax, and use them consistently
with symmetric functions.

There is also the dual Yang Baxter basis, the Kazhdan-Lusztig basis, ...:

    sage: YB = H.yang_baxter(spectral_parameters, dual = True).basis()
    sage: H.kazhdan_lusztig()
    sage: 


Here are some other common features:
    
The Jucis-Murphy elements:
    sage: jm = H.jucis_murphy()
    sage: jm[2] * jm[3]

The commutative algebra generated by those:
    sage: H.jucis_murphy_algebra()


Let us now consider the affine Hecke algebra
    sage: W = WeylGroup(["A", 3, 1])
    sage: H = HeckeAlgebra(QQ, W)
    The q-Hecke algebra of the Weyl group of type [A,3,1]

As in the classical case, there is the T basis:
    sage: B = H.T()

But one can also consider the affine hecke algebra as the skew tensor
product `\mathbb{Q}[q][X] \otimes H(\circle W)` of the commutative
group algebra of the (co)root lattice, and the hecke algebra of type
`A_3`.

    sage: B = H.XT()

Which ever basis B we take, we define:

    sage: X = B.X()
    sage: T = B.T()

and then, for t some translation in the weyl group, or element of the
(co)root lattice, do:

    sage: X[t] * T[1] - T[1] * X[t]

Note: would we want exponential notation X^t ???

Note: the combinatorics for expressing X[t] in the T basis is readilly
implemented in the root system code. See the signs_of_alcove_walk
method in weight_lattice_realization.py. It should be in
root_lattice_realization.py.

We can also define the intertwining operators:
    sage: tau = X.tau()
    sage: tau[2] * ...

Note: X, tau, ... could be defined in a category
WithEmbeddingOfQuotientOfAffineHeckeAlgebra (better name???) so that
quotients of the affine hecke algebra (like the Hecke group algebra)
could beneficiate from it. See:

http://mupad-combinat.svn.sourceforge.net/viewvc/mupad-combinat/trunk/MuPAD-Combinat/lib/EXAMPLES/HeckeGroupAlgebra.mu

Other features:

* calibrated representations / calibrated graphs

* double affine hecke algebra

    sage: H = DoubleAffineHeckeAlgebra(...)
    sage: B = H.YXT

* non symmetric Macdonald polynomials through intertwining operators
* ...
}}}
