= Semantic Words =

We decided to provide a more general context for mechanisms of words. With this in mind, we must implement a highly abstract word class, starting from an iterator and defining a lot of method from it. So, every "word method" must have a standard name in every other class which still implement the feature.


=== lowest method ===
the iterator 

=== low methods and properties ===
 * iterator on slice
 * length (semi decidable)
 * get item or slice  -->  iterator
 * is finite/infinite  -->  length
 * alphabet  -->
 * concatenation  
 * powers  (? problem of types)
 * to_list
 * to_string (now string_rep)
 * to_tuple
 * is_prefix_of
 * reversed iterator
 * is_suffix_of
 * is_proper_suffix_of
 * is_proper_prefix_of
 * comparaison (? problem of types)
 * hash (?)
 * emptyness
 * reversal  -->  reversed operation
 * is_palindrome  -->  check for finiteness and length and use, depending on that reversed operator
 * is_square
 * is_square_free
 * is_cube
 * is_cube_free
 * is_quasi_periodic

== middle level ==
 * is_subfactor_of
 * is_subword_of
 * 


=== high methods ===
