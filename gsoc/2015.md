= Project ideas for GSoC 2015 =

== Introduction ==
Google Summer of Code is a ''highly'' enjoyably and rewarding way to spend a summer.  

Sage is a GPL open-source mathematical software system. It is designed to be not just a computer algebra system, but more like a complete environment for doing mathematics and related calculations. It is based on a vast collection of existing open-source software tools and libraries and ties them together via Python.  Python is also the primary interface language for the user and its object-oriented way of expressing concepts is used to express calculations - of course, there are also many “normal” functions :-) Behind the scenes, the Sage library executes the commands and calculations by its own algorithms or by accessing appropriate routines from the included software packages. On top of that, there are various ways how users can interact with Sage, most notably a dynamic web-site called “Notebook”.

All projects will start with an introduction phase to learn about Sage’s internal organization and to get used to its established development process. This is documented in the documentation for developers and all students will be instructed by the mentors on how to get their hands dirty. We use Git for revision control and trac for organizing development and code review. Our license is GPLv2+. Feel free to contact Mentors before you send us project proposals.

Feel free to introduce yourself and your project idea in our [[https://groups.google.com/forum/#!forum/sage-gsoc|mailing list]].

To get a better feeling how Sage works, please check out the [[http://sagemath.org/doc/developer/index.html|developer guide]].

Shoot Simon Spicer (eigenpumpkin@gmail.com) an email if you want more details from a recent GSoC student on the actual logistics of doing a GSoC project.

<<TableOfContents()>>

== Notebook mode with execution from top to bottom ==

In the current notebook (both Sage notebook and IPython notebook) the cells can be executed in any order. From a teaching point of view this is terrible and from a scientific point of view this leads to highly non reproducible computations.

The purpose of this task is to have a new mode for the IPython notebook that would force computations from top to bottom. If a cell is executed, then the state in which it is executed must be the one you obtain by executing all the cells above it. In order to make it work, one needs to save the Python state after each cell.

Note: This is not completely Sage oriented... (see with IPython people)

|| Mentor     || ... ||
|| Difficulty || ... ||
|| Skills     || ... ||

== Native GUI ==

Adapt  [[https://code.google.com/p/spyderlib/|Spyder]] to work with Sage.

See also [[https://groups.google.com/forum/#!topic/sage-devel/87Rlenvcfrs|this thread on sage-devel]].

|| Mentor     || ... ||
|| Difficulty || ... ||
|| Skills     || ... ||

== Generic Dispatcher ==

In Sage there are various places where we can choose between several algorithms or underlying softwares to solve a problem. In Sage, this is often related to the presence of the keyword ''algorithm'' or ''method'' in methods and functions. The aim of this task is to build a generic dispatcher that would choose depending on the parameters the fastest solution available. The solution must be very light and not affect performance. The dispatch threshold must be static and decided at build time. This generic dispatcher could also be used to check coherency between the various implementations.

Note that it is different from what is called multimethods where the dispatch depends only on the input type. Here we consider a dispatcher that might also depend on the input values.

 * (draft) timeline:
  1. write a simple prototype of generic dispatcher
  2. identify Sage functions/methods that could benefit from the dispatcher and test it
  3. release a first candidate for the dispatcher
  4. Sage integration

|| Mentor     || ... ||
|| Difficulty || ... ||
|| Skills     || good knowledge of Python and notions of Cython and C ||

== Android App ==

== iOS App ==

== Computation of q-expansions of modular forms attached to elliptic curves at all cusps. ==

|| Mentor     || William Stein ||
|| Difficulty || Extreme ||
|| Skills     || Good knowledge of Python, Sage, and research-level knowledge of number theory ||

There is a well-known and easy to implement algorithm to compute the $q$-expansions at all cusps of $X_0(N)$ of the newform attached to an elliptic curve, when N is square-free,
but no such algorithm is known explicitly in general.
Being able to compute these $q$-expansions at all
cusps in general has many very interesting applications,
including determining the ramification of
modular parametrizations of elliptic curves at
cusps, and numerical computation of constants in
the functional equation of the twists of a newform.
A graduate student, Hao Chen (of University of Washington),
has new ideas to carry out these computations.  The project
is to fully implement his algorithm, get it included
in Sage, and also implement some of the interesting
applications of the algorithm.

== Wrap Functionality from PARI, e.g., Hermite Normal Forms for modules over the ring of integers of number fields. ==

|| Mentor     || William Stein ||
|| Difficulty || Extreme ||
|| Skills     || Good knowledge of Python, Sage, and graduate-level knowledge of abstract algebra and algebraic number theory ||

Pari has much new interesting functionality, e.g., for computing Hermite normal forms among other things.  This project would
involve making that functionality usable in Sage, with one application being to computation with modules over the ring
of integers of a number field.

Motivation: A Hermite Normal Form (HNF) algorithm for modules over general Dedekind domains was introduced in
Cohen's book 'Advanced topics in computational number theory'. The algorithm is currently not implemented in Sage, except in
the special case when the ring is a principal ideal domain.
Much research projects in computational number
theory would benefit from an efficient implementation
of this (very tricky and subtle) algorithm. For
example, this algorithm is needed to get anywhere with
quaternion algebras and associated Brandt modules over totally real fields.    As a complete GSoC project, it would be
reasonable to at least expose this HNF algorithm (from PARI) over the ring of integers of number fields, then use it.

== Multivariate Asymptotic Expressions ==

|| Mentor     || Daniel Krenn (backup: Clemens Heuberger) ||
|| Difficulty || Hard ||
|| Skills     || good knowledge of Python and Sage; graduate-level knowledge of mathematics is useful ||

An asymptotic expression typically contains exact terms and O-terms ([[https://en.wikipedia.org/wiki/Big_O_notation|wikipedia: Big O notation]] ), for example, n^3^ + 2*n^2^ + O(n). In the multivariate setting this notion is extended to several variables, e.g., n^2^*t + n*t^2^ + O(n) + O(t). The basic framework for this asymptotic ring is currently under development (see trac meta ticket [[http://trac.sagemath.org/ticket/17601|#17601]]). The main aim of this summer of code project is to extend its functionality to fully support the multivariate case. This includes the following parts:
    
 1. '''Advanced operations with asymptotic expressions:''' As a first step in this project operations like exponentiation, taking powers and logarithms should be implemented. This happens on a high level using the existing addition and multiplication, and thereby, get to know the existing framework.
 2. '''Implement mutlivariate growth groups:''' This would explore the full potential of the existing framework, which is already prepared for partially ordered growth groups. The conrete growth groups, in the case of lexicographic orders (e.g., terms with n*log(n)) as well as in the case of dependent variables (such as |t| <= n^(1/2)^), have to be written.
 3. '''Interplay with existing Sage-Objects ("User-Interface"):''' In order to comfortably create asymptotic expressions, a conversion from, for example (but not limited to), Sage's symbolic ring to the asymptotic ring should be established.


== SageMathCloud ==

T.B.A.

== Extending Game Theory in Sage ==

|| Mentor     || Vincent Knight ||
|| Difficulty || Medium ||
|| Skills     || Good knowledge of Python, Sage, and some knowledge of Game Theory would be advantageous ||

Recent contributions to Sage have developed Game Theoretic tools. The main aim of this summer of code project is to extend this functionality. This includes the following potential directions:

 1. '''Further integration with gambit:''' One implementation of the solution of normal form games is done through the gambit python api. This currently implements a single two player algorithm, work would be undertaken to expand this to the various algorithms available in gambit (multiple players etc...).
 2. '''Tests for degeneracy of normal form games:''' A degenerate game is a game where the Nash equilibria does not correspond to an isolated point of the strategy space. This work would involve researching, designing annd implementing algorithms to tests for degeneracy of normal form games.
 3. '''Designing of educational materials making use of SageMathCloud:''' Having Sage and solution concepts for games readily available to all in SageMathCloud make this an excellent teaching tool. A variety of teaching materials could be designed making use of screencasts, interacts and other web technologies. Furthermore, this could also involve the enhancement of the game theoretic library in Sage to include example games.

== Add support for systems of rational inequalities ==

Enable Sage users to solve systems of rational inequalities like

{{{
abs(2*x-3)/(3*x)>(x+1)/(x-2) and (4*x+5)^2/(x-3)<x+3.
}}}

For this, the way to go seems [[http://trac.sagemath.org/ticket/10224|to package]] [[https://www.usna.edu/CS/qepcadweb/B/QEPCAD.html|QEPCAD]] in such a quality that it can become an "optional package". One could then use:
{{{
sage: maxima_calculus("domain: real") #14229
sage: dnf1 = solve(abs(2*x-3)/(3*x)>(x+1)/(x-2),x)
sage: qf1 = apply(qepcad_formula.or_, map(qepcad_formula.and_, dnf1))
sage: dnf2 = solve((4*x+5)^2/(x-3)<x+3,x)
sage: qf2 = apply(qepcad_formula.or_, map(qepcad_formula.and_, dnf2))
sage: qepcad(qepcad_formula.and_(qf1, qf2), vars='(x)')
}}}
to get the solution `"0 < x < 2"`.

A further topic would be to introduce shorter syntax (infix boolean operators, inequality chains) for the above, to do something like the following:
{{{
sage: dnf1 _and_ dnf2
0 < x < 2
}}}
Note that `0 < x < 2` would not be a string here, but a Sage object. Also, `dnf1` and `dnf2` should be in the new syntax, instead of the current "list of lists" DNF.

Finally, also the something like the following should work:
{{{
sage: solve(0 < x < 2 _or_ x > 1, x)
x > 0
}}}

Motivation: Rational inequalities are a topic of our institute's 1st year classes, and Mathematica is currently used there.

(I cannot really offer to be a mentor here, because I did not do any Sage development yet --jondo)

|| Mentor     || ... ||
|| Difficulty || ... ||
|| Skills     || C programming, Sage packaging, cross platform testing ||

== Extending Matroid Theory functionality ==

|| Mentor     || Stefan van Zwam; co-mentor: Michael Welsh ||
|| Difficulty || Medium ||
|| Skills     || Good knowledge of Python, Sage, and some knowledge of Matroid Theory would be advantageous ||

The basic code for dealing with matroids in Sage is fairly mature, but many enhancements are still desirable. Among those:

 1. '''Connectivity algorithms:''' Implement efficient tests for the connectivity of a matroid. In particular the $(r(M))^2 |E|$ algorithm for 3-connectivity by Bixby and Cunningham (1979), and generic algorithms based on either Tutte's Linking Theorem or Matroid Intersection.
 2. '''An improved catalog:''' This could be a warm-up task for the first two weeks. Enhance the matroid catalog with some options, such as adding options to prescribe the field of a representation.
 3. '''Automorphisms and certificates:''' Many matroid test methods are currently True/False. In many cases, it makes sense to return a certificate of the claim, such as an isomorphism in case two matroids are determined to be isomorphic.
 4. '''Representability tests:''' Test if a given abstract matroid is binary, ternary, quaternary, regular, ...
 5. '''Framework for classes of representable matroids:''' This can take two directions. First, a parent-like class such as BinaryMatroids, which symbolically represents all binary matroids, and has methods for extending, membership tests, etc. Second, a finite collection of matroids (such as all binary matroids without a P7-minor up to 9 elements), where each matroid stores information about its allowed extensions and coextensions for faster generation and membership testing.
