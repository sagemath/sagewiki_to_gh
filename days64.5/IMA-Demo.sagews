︠978ac9d9-652e-4aed-a3aa-ed26b7e8a178osa︠
%auto
typeset_mode(False, display=False)
︡57cfaef6-a5f0-42f4-abad-50f37a0d6fd3︡{"auto":true}︡
︠e41cf3d1-e1a9-41ba-8cc6-7b668d93514dos︠
B = Matrix([[0,1],[-1,0]]); B

︡215431b5-22d9-4bf4-974e-1a6d59707b4a︡{"stdout":"[ 0  1]\n[-1  0]\n"}︡
︠8dce36ec-c835-46c6-a56a-764a7c9d8090os︠
ClusterQuiver??
︡60a24df5-d63b-4cb3-b9e9-bafcc8eaec26︡{"code":{"source":"   File: /projects/sage/sage-6.7/src/sage/misc/lazy_import.pyx\n   Source:\n   class ClusterQuiver(SageObject):\n    \"\"\"\n    The *quiver* associated to an *exchange matrix*.\n\n    INPUT:\n\n    - ``data`` -- can be any of the following::\n\n        * QuiverMutationType\n        * str - a string representing a QuiverMutationType or a common quiver type (see Examples)\n        * ClusterQuiver\n        * Matrix - a skew-symmetrizable matrix\n        * DiGraph - must be the input data for a quiver\n        * List of edges - must be the edge list of a digraph for a quiver\n\n    - ``frozen`` -- (default:``None``) sets the number of frozen variables if the input type is a DiGraph, it is ignored otherwise.\n\n    EXAMPLES:\n\n        from a QuiverMutationType::\n\n            sage: Q = ClusterQuiver(['A',5]); Q\n            Quiver on 5 vertices of type ['A', 5]\n\n            sage: Q = ClusterQuiver(['B',2]); Q\n            Quiver on 2 vertices of type ['B', 2]\n            sage: Q2 = ClusterQuiver(['C',2]); Q2\n            Quiver on 2 vertices of type ['B', 2]\n            sage: MT = Q.mutation_type(); MT.standard_quiver() == Q\n            True\n            sage: MT = Q2.mutation_type(); MT.standard_quiver() == Q2\n            False\n\n            sage: Q = ClusterQuiver(['A',[2,5],1]); Q\n            Quiver on 7 vertices of type ['A', [2, 5], 1]\n\n            sage: Q = ClusterQuiver(['A', [5,0],1]); Q\n            Quiver on 5 vertices of type ['D', 5]\n            sage: Q.is_finite()\n            True\n            sage: Q.is_acyclic()\n            False\n\n            sage: Q = ClusterQuiver(['F', 4, [2,1]]); Q\n            Quiver on 6 vertices of type ['F', 4, [1, 2]]\n            sage: MT = Q.mutation_type(); MT.standard_quiver() == Q\n            False\n            sage: dg = Q.digraph(); Q.mutate([2,1,4,0,5,3])\n            sage: dg2 = Q.digraph(); dg2.is_isomorphic(dg,edge_labels=True)\n            False\n            sage: dg2.is_isomorphic(MT.standard_quiver().digraph(),edge_labels=True)\n            True\n\n            sage: Q = ClusterQuiver(['G',2, (3,1)]); Q\n            Quiver on 4 vertices of type ['G', 2, [1, 3]]\n            sage: MT = Q.mutation_type(); MT.standard_quiver() == Q\n            False\n\n            sage: Q = ClusterQuiver(['GR',[3,6]]); Q\n            Quiver on 4 vertices of type ['D', 4]\n            sage: MT = Q.mutation_type(); MT.standard_quiver() == Q\n            False\n\n            sage: Q = ClusterQuiver(['GR',[3,7]]); Q\n            Quiver on 6 vertices of type ['E', 6]\n\n            sage: Q = ClusterQuiver(['TR',2]); Q\n            Quiver on 3 vertices of type ['A', 3]\n            sage: MT = Q.mutation_type(); MT.standard_quiver() == Q\n            False\n            sage: Q.mutate([1,0]); MT.standard_quiver() == Q\n            True\n\n            sage: Q = ClusterQuiver(['TR',3]); Q\n            Quiver on 6 vertices of type ['D', 6]\n            sage: MT = Q.mutation_type(); MT.standard_quiver() == Q\n            False\n\n        from a ClusterQuiver::\n\n            sage: Q = ClusterQuiver(['A',[2,5],1]); Q\n            Quiver on 7 vertices of type ['A', [2, 5], 1]\n            sage: T = ClusterQuiver( Q ); T\n            Quiver on 7 vertices of type ['A', [2, 5], 1]\n\n        from a Matrix::\n\n            sage: Q = ClusterQuiver(['A',[2,5],1]); Q\n            Quiver on 7 vertices of type ['A', [2, 5], 1]\n            sage: T = ClusterQuiver( Q._M ); T\n            Quiver on 7 vertices\n\n            sage: Q = ClusterQuiver( matrix([[0,1,-1],[-1,0,1],[1,-1,0],[1,2,3]]) ); Q\n            Quiver on 4 vertices with 1 frozen vertex\n\n            sage: Q = ClusterQuiver( matrix([]) ); Q\n            Quiver without vertices\n\n        from a DiGraph::\n\n            sage: Q = ClusterQuiver(['A',[2,5],1]); Q\n            Quiver on 7 vertices of type ['A', [2, 5], 1]\n            sage: T = ClusterQuiver( Q._digraph ); T\n            Quiver on 7 vertices\n\n            sage: Q = ClusterQuiver( DiGraph([[1,2],[2,3],[3,4],[4,1]]) ); Q\n            Quiver on 4 vertices\n\n        from a List of edges::\n\n            sage: Q = ClusterQuiver(['A',[2,5],1]); Q\n            Quiver on 7 vertices of type ['A', [2, 5], 1]\n            sage: T = ClusterQuiver( Q._digraph.edges() ); T\n            Quiver on 7 vertices\n\n            sage: Q = ClusterQuiver( [[1,2],[2,3],[3,4],[4,1]] ); Q\n            Quiver on 4 vertices\n\n    TESTS::\n\n        sage: Q = ClusterQuiver(DiGraph([[1,1]]))\n        Traceback (most recent call last):\n        ...\n        ValueError: The input DiGraph contains a loop\n\n        sage: Q = ClusterQuiver([[1,1]])\n        Traceback (most recent call last):\n        ...\n        ValueError: The input DiGraph contains a loop\n\n        sage: Q = ClusterQuiver(DiGraph([[1, 0],[0,1]]))\n        Traceback (most recent call last):\n        ...\n        ValueError: The input DiGraph contains two-cycles\n\n        sage: Q = ClusterQuiver('whatever')\n        Traceback (most recent call last):\n        ...\n        ValueError: The input data was not recognized.\n    \"\"\"\n    def __init__( self, data, frozen=None ):\n        \"\"\"\n        TESTS::\n\n            sage: Q = ClusterQuiver(['A',4])\n            sage: TestSuite(Q).run()\n        \"\"\"\n        from cluster_seed import ClusterSeed\n        from sage.matrix.matrix import Matrix\n\n        # constructs a quiver from a mutation type\n        if type( data ) in [QuiverMutationType_Irreducible,QuiverMutationType_Reducible]:\n            if frozen is not None:\n                print 'The input data is a quiver, therefore the additional parameter frozen is ignored.'\n\n            mutation_type = data\n            self.__init__( mutation_type.standard_quiver() )\n\n        # constructs a quiver from string representing a mutation type or a common quiver type (see Examples)\n        # NOTE: for now, any string representing a *reducible type* is coerced into the standard quiver, but there is now more flexibility in how to input a connected (irreducible) quiver.\n        elif type( data ) in [list,tuple] and ( isinstance(data[0], str) or all(type( comp ) in [list,tuple] and isinstance(comp[0], str) for comp in data) ):\n            if frozen is not None:\n                print 'The input data is a quiver, therefore the additional parameter frozen is ignored.'\n            mutation_type = QuiverMutationType( data )\n\n            # The command QuiverMutationType_Irreducible (which is not imported globally) already creates the desired digraph as long as we bypass the mutation type checking of QuiverMutationType and format the input appropriately.  Thus we handle several special cases this way.\n            if len(data) == 2 and isinstance(data[0], str):\n                if data[0] == 'TR' or data[0] == 'GR' or (data[0] == 'C' and data[1] == 2):\n                    if data[1] in ZZ:\n                        quiv = ClusterQuiver( QuiverMutationType_Irreducible( data[0], data[1] )._digraph )\n                        quiv._mutation_type = mutation_type\n                        self.__init__( quiv )\n                    elif isinstance(data[1], list):\n                        quiv = ClusterQuiver( QuiverMutationType_Irreducible( data[0], tuple(data[1]) )._digraph )\n                        quiv._mutation_type = mutation_type\n                        self.__init__( quiv )\n                else:\n                    self.__init__( mutation_type.standard_quiver() )\n            elif len(data) == 3 and isinstance(data[0], str):\n                if (data[0] == 'F' and data[1] == 4 and data[2] == [2,1])   or (data[0] == 'G' and data[1] == 2 and data[2] == [3,1]):\n                    quiv = ClusterQuiver( QuiverMutationType_Irreducible( data[0], data[1], tuple(data[2]) )._digraph )\n                    quiv._mutation_type = mutation_type\n                    self.__init__( quiv )\n                elif (data[0] == 'F' and data[1] == 4 and data[2] == (2,1) )   or (data[0] == 'G' and data[1] == 2 and data[2] == (3,1) ):\n                    quiv = ClusterQuiver( QuiverMutationType_Irreducible( data[0], data[1], data[2] )._digraph )\n                    quiv._mutation_type = mutation_type\n                    self.__init__( quiv )\n                elif data[0] == 'A' and isinstance(data[1], list) and data[2] == 1:\n                    if len(data[1]) == 2 and min(data[1]) == 0:\n                        quiv = ClusterQuiver( QuiverMutationType_Irreducible( data[0], tuple(data[1]), data[2] )._digraph )\n                        quiv._mutation_type = mutation_type\n                        self.__init__( quiv )\n                    else:\n                        self.__init__( mutation_type.standard_quiver() )\n\n                elif data[0] == 'A' and isinstance(data[1], tuple) and data[2] == 1:\n                    if len(data[1]) == 2 and min(data[1]) == 0:\n                        quiv = ClusterQuiver( QuiverMutationType_Irreducible( data[0], data[1], data[2] )._digraph )\n                        quiv._mutation_type = mutation_type\n                        self.__init__( quiv )\n                    else:\n                        self.__init__( mutation_type.standard_quiver() )\n\n                else:\n                    self.__init__( mutation_type.standard_quiver() )\n            else:\n                self.__init__( mutation_type.standard_quiver() )\n\n         # constructs a quiver from a cluster seed\n        elif isinstance(data, ClusterSeed):\n            self.__init__( data.quiver() )\n\n        # constructs a quiver from a quiver\n        elif isinstance(data, ClusterQuiver):\n            if frozen is not None:\n                print 'The input data is a quiver, therefore the additional parameter frozen is ignored.'\n\n            self._M = copy(data._M)\n            self._n = data._n\n            self._m = data._m\n            self._digraph = copy( data._digraph )\n            self._mutation_type = data._mutation_type\n            self._description = data._description\n\n        # constructs a quiver from a matrix\n        elif isinstance(data, Matrix):\n            if not _principal_part(data).is_skew_symmetrizable( positive=True ):\n                raise ValueError('The principal part of the matrix data must be skew-symmetrizable.')\n            if frozen is not None:\n                print 'The input data is a matrix, therefore the additional parameter frozen is ignored.'\n\n            self._M = copy(data).sparse_matrix()\n            self._n = n = self._M.ncols()\n            self._m = m = self._M.nrows() - self._n\n            self._digraph = _matrix_to_digraph( self._M )\n            self._mutation_type = None\n            if n+m == 0:\n                self._description = 'Quiver without vertices'\n            elif n+m == 1:\n                self._description = 'Quiver on %d vertex' %(n+m)\n            else:\n                self._description = 'Quiver on %d vertices' %(n+m)\n\n        # constructs a quiver from a digraph\n        elif isinstance(data, DiGraph):\n            if frozen is None:\n                frozen = 0\n            elif not ZZ(frozen) == frozen:\n                raise ValueError(\"The optional argument frozen (=%s) must be an integer.\"%frozen)\n            m = self._m = frozen\n            n = self._n = data.order() - m\n            dg = copy( data )\n            edges = data.edges(labels=False)\n            if any( (a,a) in edges for a in data.vertices() ):\n                raise ValueError(\"The input DiGraph contains a loop\")\n            if any( (b,a) in edges for (a,b) in edges ):\n                raise ValueError(\"The input DiGraph contains two-cycles\")\n            if not set(dg.vertices()) == set(range(n+m)):\n                dg.relabel()\n            if dg.has_multiple_edges():\n                multi_edges = {}\n                for v1,v2,label in dg.multiple_edges():\n                    if label not in ZZ:\n                        raise ValueError(\"The input DiGraph contains multiple edges labeled by non-integers\")\n                    elif (v1,v2) in multi_edges:\n                        multi_edges[(v1,v2)] += label\n                    else:\n                        multi_edges[(v1,v2)] = label\n                    dg.delete_edge(v1,v2)\n                dg.add_edges( [ (v1,v2,multi_edges[(v1,v2)]) for v1,v2 in multi_edges ] )\n            for edge in dg.edge_iterator():\n                if edge[0] >= n and edge[1] >= n:\n                    raise ValueError(\"The input digraph contains edges within the frozen vertices\")\n                if edge[2] is None:\n                    dg.set_edge_label( edge[0], edge[1], (1,-1) )\n                    edge = (edge[0],edge[1],(1,-1))\n                elif edge[2] in ZZ:\n                    dg.set_edge_label( edge[0], edge[1], (edge[2],-edge[2]) )\n                    edge = (edge[0],edge[1],(edge[2],-edge[2]))\n                elif isinstance(edge[2], list) and len(edge[2]) != 2:\n                    raise ValueError(\"The input digraph contains an edge with the wrong type of list as a label.\")\n                elif isinstance(edge[2], list) and len(edge[2]) == 2:\n                    dg.set_edge_label( edge[0], edge[1], (edge[2][0], edge[2][1]))\n                    edge = (edge[0],edge[1],(edge[2][0],edge[2][1]))\n                elif ( edge[0] >= n or edge[1] >= n ) and not edge[2][0] == - edge[2][1]:\n                    raise ValueError(\"The input digraph contains an edge to or from a frozen vertex which is not skew-symmetric.\")\n                if edge[2][0] < 0:\n                    raise ValueError(\"The input digraph contains an edge of the form (a,-b) with negative a.\")\n\n            M = _edge_list_to_matrix( dg.edge_iterator(), n, m )\n            if not _principal_part(M).is_skew_symmetrizable( positive=True ):\n                raise ValueError(\"The input digraph must be skew-symmetrizable\")\n            self._digraph = dg\n            self._M = M\n            if n+m == 0:\n                self._description = 'Quiver without vertices'\n            elif n+m == 1:\n                self._description = 'Quiver on %d vertex' %(n+m)\n            else:\n                self._description = 'Quiver on %d vertices' %(n+m)\n            self._mutation_type = None\n\n        # if data is a list of edges, the appropriate digraph is constructed.\n\n        elif isinstance(data,list) and all(isinstance(x,(list,tuple)) for x in data ):\n            dg = DiGraph( data )\n            self.__init__(data=dg, frozen=frozen )\n\n        # otherwise, an error is raised\n        else:\n            raise ValueError(\"The input data was not recognized.\")\n\n    def __eq__(self, other):\n        \"\"\"\n        Returns ``True`` if ``self`` and ``other`` represent the same quiver.\n\n        EXAMPLES::\n\n            sage: Q = ClusterQuiver(['A',5])\n            sage: T = Q.mutate( 2, inplace=False )\n            sage: Q.__eq__( T )\n            False\n            sage: T.mutate( 2 )\n            sage: Q.__eq__( T )\n            True\n        \"\"\"\n        return isinstance(other, ClusterQuiver) and self._M == other._M\n\n    def _repr_(self):\n        \"\"\"\n        Returns the description of ``self``.\n\n        EXAMPLES::\n\n            sage: Q = ClusterQuiver(['A',5])\n            sage: Q._repr_()\n            \"Quiver on 5 vertices of type ['A', 5]\"\n        \"\"\"\n        name = self._description\n        if self._mutation_type:\n            if isinstance(self._mutation_type, str):\n                name += ' of ' + self._mutation_type\n            else:\n                name += ' of type ' + str(self._mutation_type)\n        if self._m == 1:\n            name += ' with %s frozen vertex'%self._m\n        elif self._m > 1:\n            name += ' with %s frozen vertices'%self._m\n        return name\n\n    def plot(self, circular=True, center=(0,0), directed=True, mark=None, save_pos=False):\n        \"\"\"\n        Returns the plot of the underlying digraph of ``self``.\n\n        INPUT:\n\n        - ``circular`` -- (default:True) if True, the circular plot is chosen, otherwise >>spring<< is used.\n        - ``center`` -- (default:(0,0)) sets the center of the circular plot, otherwise it is ignored.\n        - ``directed`` -- (default: True) if True, the directed version is shown, otherwise the undirected.\n        - ``mark`` -- (default: None) if set to i, the vertex i is highlighted.\n        - ``save_pos`` -- (default:False) if True, the positions of the vertices are saved.\n\n        EXAMPLES::\n\n            sage: Q = ClusterQuiver(['A',5])\n            sage: pl = Q.plot()\n            sage: pl = Q.plot(circular=True)\n        \"\"\"\n        from sage.plot.colors import rainbow\n        from sage.graphs.graph_generators import GraphGenerators\n        from sage.all import e,pi,I\n        graphs = GraphGenerators()\n        # returns positions for graph vertices on two concentric cycles with radius 1 and 2\n        def _graphs_concentric_circles(n,m):\n            g1 = graphs.CycleGraph(n).get_pos()\n            g2 = graphs.CycleGraph(m).get_pos()\n            for i in g2:\n                z = CC(g2[i])*e**(-pi*I/(2*m))\n                g2[i] = (z.real_part(),z.imag_part())\n            for i in range(m):\n                g1[n+i] = [2*g2[i][0], 2*g2[i][1]]\n            return g1\n\n        n, m = self._n, self._m\n        colors = rainbow(11)\n        color_dict = { colors[0]:[], colors[1]:[], colors[6]:[], colors[5]:[] }\n        if directed:\n            dg = DiGraph( self._digraph )\n        else:\n            dg = Graph( self._digraph )\n        for edge in dg.edges():\n            v1,v2,(a,b) = edge\n            if v1 < n and v2 < n:\n                if (a,b) == (1,-1):\n                    color_dict[ colors[0] ].append((v1,v2))\n                else:\n                    color_dict[ colors[6] ].append((v1,v2))\n            else:\n                if (a,b) == (1,-1):\n                    color_dict[ colors[1] ].append((v1,v2))\n                else:\n                    color_dict[ colors[5] ].append((v1,v2))\n            if a == -b:\n                if a == 1:\n                    dg.set_edge_label( v1,v2,'' )\n                else:\n                    dg.set_edge_label( v1,v2,a )\n        if mark is not None:\n            if mark < n:\n                partition = (range(mark)+range(mark+1,n),range(n,n+m),[mark])\n            elif mark > n:\n                partition = (range(n),range(n,mark)+range(mark+1,n+m),[mark])\n            else:\n                raise ValueError(\"The given mark is not a vertex of self.\")\n        else:\n            partition = (range(n),range(n,n+m),[])\n        vertex_color_dict = {}\n        vertex_color_dict[ colors[0] ] = partition[0]\n        vertex_color_dict[ colors[6] ] = partition[1]\n        vertex_color_dict[ colors[4] ] = partition[2]\n\n        options = {\n            'graph_border' : True,\n            'edge_colors': color_dict,\n            'vertex_colors': vertex_color_dict,\n            'edge_labels' : True,\n        }\n        if circular:\n            pp = _graphs_concentric_circles( n, m )\n            for v in pp:\n                pp[v] = (pp[v][0]+center[0],pp[v][1]+center[1])\n            options[ 'pos' ] = pp\n        return dg.plot( **options )\n\n    def show(self, fig_size=1, circular=False, directed=True, mark=None, save_pos=False):\n        \"\"\"\n        Shows the plot of the underlying digraph of ``self``.\n\n        INPUT:\n\n        - ``fig_size`` -- (default: 1) factor by which the size of the plot is multiplied.\n        - ``circular`` -- (default: False) if True, the circular plot is chosen, otherwise >>spring<< is used.\n        - ``directed`` -- (default: True) if True, the directed version is shown, otherwise the undirected.\n        - ``mark`` -- (default: None) if set to i, the vertex i is highlighted.\n        - ``save_pos`` -- (default:False) if True, the positions of the vertices are saved.\n\n        TESTS::\n\n            sage: Q = ClusterQuiver(['A',5])\n            sage: Q.show() # long time\n        \"\"\"\n        n, m = self._n, self._m\n        plot = self.plot( circular=circular, directed=directed, mark=mark, save_pos=save_pos )\n        if circular:\n            plot.show( figsize=[fig_size*3*(n+m)/4+1,fig_size*3*(n+m)/4+1] )\n        else:\n            plot.show( figsize=[fig_size*n+1,fig_size*n+1] )\n\n    def interact(self, fig_size=1, circular=True):\n        \"\"\"\n        Only in notebook mode. Starts an interactive window for cluster seed mutations.\n\n        INPUT:\n\n        - ``fig_size`` -- (default: 1) factor by which the size of the plot is multiplied.\n        - ``circular`` -- (default: False) if True, the circular plot is chosen, otherwise >>spring<< is used.\n\n        TESTS::\n\n            sage: Q = ClusterQuiver(['A',4])\n            sage: Q.interact() # long time\n            'The interactive mode only runs in the Sage notebook.'\n        \"\"\"\n        from sage.plot.plot import EMBEDDED_MODE\n        from sagenb.notebook.interact import interact, selector\n        from sage.misc.all import html,latex\n\n        if not EMBEDDED_MODE:\n            return \"The interactive mode only runs in the Sage notebook.\"\n        else:\n            seq = []\n            sft = [True]\n            sss = [True]\n            ssm = [True]\n            ssl = [True]\n            @interact\n            def player(k=selector(values=range(self._n),nrows = 1,label='Mutate at: '), show_seq=(\"Mutation sequence:\", True), show_matrix=(\"B-Matrix:\", True), show_lastmutation=(\"Show last mutation:\", True) ):\n                ft,ss,sm,sl = sft.pop(), sss.pop(), ssm.pop(), ssl.pop()\n                if ft:\n                    self.show(fig_size=fig_size, circular=circular)\n                elif show_seq is not ss or show_matrix is not sm or show_lastmutation is not sl:\n                    if seq and show_lastmutation:\n                        self.show(fig_size=fig_size, circular=circular, mark=seq[len(seq)-1])\n                    else:\n                        self.show(fig_size=fig_size, circular=circular )\n                else:\n                    self.mutate(k)\n                    seq.append(k)\n                    if not show_lastmutation:\n                        self.show(fig_size=fig_size, circular=circular)\n                    else:\n                        self.show(fig_size=fig_size, circular=circular,mark=k)\n                sft.append(False)\n                sss.append(show_seq)\n                ssm.append(show_matrix)\n                ssl.append(show_lastmutation)\n                if show_seq: html( \"Mutation sequence: $\" + str( [ seq[i] for i in xrange(len(seq)) ] ).strip('[]') + \"$\" )\n                if show_matrix:\n                    html( \"B-Matrix:\" )\n                    m = self._M\n                    #m = matrix(range(1,self._n+1),sparse=True).stack(m)\n                    m = latex(m)\n                    m = m.split('(')[1].split('\\\\right')[0]\n                    html( \"$ $\" )\n                    html( \"$\\\\begin{align*} \" + m + \"\\\\end{align*}$\" )\n                    #html( \"$\" + m + \"$\" )\n                    html( \"$ $\" )\n\n    def save_image(self,filename,circular=False):\n        \"\"\"\n        Saves the plot of the underlying digraph of ``self``.\n\n        INPUT:\n\n        - ``filename`` -- the filename the image is saved to.\n        - ``circular`` -- (default: False) if True, the circular plot is chosen, otherwise >>spring<< is used.\n\n        EXAMPLES::\n\n            sage: Q = ClusterQuiver(['F',4,[1,2]])\n            sage: Q.save_image(os.path.join(SAGE_TMP, 'sage.png'))\n        \"\"\"\n        graph_plot = self.plot( circular=circular )\n        graph_plot.save( filename=filename )\n\n    def qmu_save(self,filename=None):\n        \"\"\"\n        Saves a .qmu file of ``self`` that can then be opened in Bernhard Keller's Quiver Applet.\n\n        INPUT:\n\n        - ``filename`` -- the filename the image is saved to.\n\n        If a filename is not specified, the default name is from_sage.qmu in the current sage directory.\n\n        EXAMPLES::\n\n            sage: Q = ClusterQuiver(['F',4,[1,2]])\n            sage: Q.qmu_save(os.path.join(SAGE_TMP, 'sage.qmu'))\n\n        Make sure we can save quivers with `m != n` frozen variables, see :trac:`14851`::\n\n            sage: S=ClusterSeed(['A',3])\n            sage: T1=S.principal_extension()\n            sage: T2=T1.principal_extension(ignore_coefficients=True)\n            sage: Q=T2.quiver()\n            sage: Q.qmu_save(os.path.join(SAGE_TMP, 'sage.qmu'))\n        \"\"\"\n        M = self.b_matrix()\n        if self.m() > 0:\n            from sage.matrix.constructor import Matrix\n            from sage.matrix.constructor import block_matrix\n            M1 = M.matrix_from_rows(range(self.n()))\n            M2 = M.matrix_from_rows(range(self.n(),self.n()+self.m()))\n            M3 = Matrix(self.m(),self.m())\n            M = block_matrix([[M1,-M2.transpose()],[M2,M3]])\n        dg = self.digraph()\n        dg.plot(save_pos=True)\n        PP = dg.get_pos()\n        m = M.ncols()\n        if filename is None:\n            filename = 'from_sage.qmu'\n        try:\n            self._default_filename = filename\n        except AttributeError:\n            pass\n        if filename[-4:] != '.qmu':\n            filename = filename + '.qmu'\n        myfile = open(filename, 'w')\n        myfile.write('//Number of points'); myfile.write('\\n')\n        myfile.write(str(m)); myfile.write('\\n')\n        myfile.write('//Vertex radius'); myfile.write('\\n')\n        myfile.write(str(9)); myfile.write('\\n')\n        myfile.write('//Labels shown'); myfile.write('\\n')\n        myfile.write(str(1)); myfile.write('\\n')\n        myfile.write('//Matrix'); myfile.write('\\n')\n        myfile.write(str(m)); myfile.write(' '); myfile.write(str(m)); myfile.write('\\n')\n        for i in range(m):\n            for j in range(m):\n                myfile.write(str(M[i,j])); myfile.write(' ')\n            myfile.write('\\n')\n        myfile.write('//Points'); myfile.write('\\n')\n        for i in range(m):\n            myfile.write(str(9)); myfile.write(' '); myfile.write(str(100*PP[i][0])); myfile.write(' ');\n            myfile.write(str(100*PP[i][1]));\n            if i > self.n()-1:\n                myfile.write(' '); myfile.write(str(1))\n            myfile.write('\\n')\n        myfile.write('//Historycounter'); myfile.write('\\n')\n        myfile.write(str(-1)); myfile.write('\\n')\n        myfile.write('//History'); myfile.write('\\n'); myfile.write('\\n')\n        myfile.write('//Cluster is null');\n        myfile.close()\n\n    def b_matrix(self):\n        \"\"\"\n        Returns the b-matrix of ``self``.\n\n        EXAMPLES::\n\n            sage: ClusterQuiver(['A',4]).b_matrix()\n            [ 0  1  0  0]\n            [-1  0 -1  0]\n            [ 0  1  0  1]\n            [ 0  0 -1  0]\n\n            sage: ClusterQuiver(['B',4]).b_matrix()\n            [ 0  1  0  0]\n            [-1  0 -1  0]\n            [ 0  1  0  1]\n            [ 0  0 -2  0]\n\n            sage: ClusterQuiver(['D',4]).b_matrix()\n            [ 0  1  0  0]\n            [-1  0 -1 -1]\n            [ 0  1  0  0]\n            [ 0  1  0  0]\n\n            sage: ClusterQuiver(QuiverMutationType([['A',2],['B',2]])).b_matrix()\n            [ 0  1  0  0]\n            [-1  0  0  0]\n            [ 0  0  0  1]\n            [ 0  0 -2  0]\n        \"\"\"\n        return copy( self._M )\n\n    def digraph(self):\n        \"\"\"\n        Returns the underlying digraph of ``self``.\n\n        EXAMPLES::\n\n            sage: ClusterQuiver(['A',1]).digraph()\n            Digraph on 1 vertex\n            sage: ClusterQuiver(['A',1]).digraph().vertices()\n            [0]\n            sage: ClusterQuiver(['A',1]).digraph().edges()\n            []\n\n            sage: ClusterQuiver(['A',4]).digraph()\n            Digraph on 4 vertices\n            sage: ClusterQuiver(['A',4]).digraph().edges()\n            [(0, 1, (1, -1)), (2, 1, (1, -1)), (2, 3, (1, -1))]\n\n            sage: ClusterQuiver(['B',4]).digraph()\n            Digraph on 4 vertices\n            sage: ClusterQuiver(['A',4]).digraph().edges()\n            [(0, 1, (1, -1)), (2, 1, (1, -1)), (2, 3, (1, -1))]\n\n            sage: ClusterQuiver(QuiverMutationType([['A',2],['B',2]])).digraph()\n            Digraph on 4 vertices\n\n            sage: ClusterQuiver(QuiverMutationType([['A',2],['B',2]])).digraph().edges()\n            [(0, 1, (1, -1)), (2, 3, (1, -2))]\n        \"\"\"\n        return copy( self._digraph )\n\n    def mutation_type(self):\n        \"\"\"\n        Returns the mutation type of ``self``.\n\n        Returns the mutation_type of each connected component of self if it can be determined,\n        otherwise, the mutation type of this component is set to be unknown.\n\n        The mutation types of the components are ordered by vertex labels.\n\n        If you do many type recognitions, you should consider to save\n        exceptional mutation types using\n        `meth`:sage.combinat.cluster_algebra_quiver.quiver_mutation_type.save_exceptional_data\n\n        WARNING:\n\n        - All finite types can be detected,\n        - All affine types can be detected, EXCEPT affine type D (the algorithm is not yet implemented)\n        - All exceptional types can be detected.\n\n        EXAMPLES::\n\n            sage: ClusterQuiver(['A',4]).mutation_type()\n            ['A', 4]\n            sage: ClusterQuiver(['A',(3,1),1]).mutation_type()\n            ['A', [1, 3], 1]\n            sage: ClusterQuiver(['C',2]).mutation_type()\n            ['B', 2]\n            sage: ClusterQuiver(['B',4,1]).mutation_type()\n            ['BD', 4, 1]\n\n        finite types::\n\n            sage: Q = ClusterQuiver(['A',5])\n            sage: Q._mutation_type = None\n            sage: Q.mutation_type()\n            ['A', 5]\n\n            sage: Q = ClusterQuiver([(0,1),(1,2),(2,3),(3,4)])\n            sage: Q.mutation_type()\n            ['A', 5]\n\n        affine types::\n\n            sage: Q = ClusterQuiver(['E',8,[1,1]]); Q\n            Quiver on 10 vertices of type ['E', 8, [1, 1]]\n            sage: Q._mutation_type = None; Q\n            Quiver on 10 vertices\n            sage: Q.mutation_type() # long time\n            ['E', 8, [1, 1]]\n\n        the not yet working affine type D (unless user has saved small classical quiver data)::\n\n            sage: Q = ClusterQuiver(['D',4,1])\n            sage: Q._mutation_type = None\n            sage: Q.mutation_type() # todo: not implemented\n            ['D', 4, 1]\n\n        the exceptional types::\n\n            sage: Q = ClusterQuiver(['X',6])\n            sage: Q._mutation_type = None\n            sage: Q.mutation_type() # long time\n            ['X', 6]\n\n        examples from page 8 of Keller's article \"Cluster algebras, quiver representations\n        and triangulated categories\" (arXiv:0807.1960)::\n\n            sage: dg = DiGraph(); dg.add_edges([(9,0),(9,4),(4,6),(6,7),(7,8),(8,3),(3,5),(5,6),(8,1),(2,3)])\n            sage: ClusterQuiver( dg ).mutation_type() # long time\n            ['E', 8, [1, 1]]\n\n            sage: dg = DiGraph( { 0:[3], 1:[0,4], 2:[0,6], 3:[1,2,7], 4:[3,8], 5:[2], 6:[3,5], 7:[4,6], 8:[7] } )\n            sage: ClusterQuiver( dg ).mutation_type() # long time\n            ['E', 8, 1]\n\n            sage: dg = DiGraph( { 0:[3,9], 1:[0,4], 2:[0,6], 3:[1,2,7], 4:[3,8], 5:[2], 6:[3,5], 7:[4,6], 8:[7], 9:[1] } )\n            sage: ClusterQuiver( dg ).mutation_type() # long time\n            ['E', 8, [1, 1]]\n\n        infinite types::\n\n            sage: Q = ClusterQuiver(['GR',[4,9]])\n            sage: Q._mutation_type = None\n            sage: Q.mutation_type()\n            'undetermined infinite mutation type'\n\n        reducible types::\n\n            sage: Q = ClusterQuiver([['A', 3], ['B', 3]])\n            sage: Q._mutation_type = None\n            sage: Q.mutation_type()\n            [ ['A', 3], ['B', 3] ]\n\n            sage: Q = ClusterQuiver([['A', 3], ['T', [4,4,4]]])\n            sage: Q._mutation_type = None\n            sage: Q.mutation_type()\n            [['A', 3], 'undetermined infinite mutation type']\n\n            sage: Q = ClusterQuiver([['A', 3], ['B', 3], ['T', [4,4,4]]])\n            sage: Q._mutation_type = None\n            sage: Q.mutation_type()\n            [['A', 3], ['B', 3], 'undetermined infinite mutation type']\n\n            sage: Q = ClusterQuiver([[0,1,2],[1,2,2],[2,0,2],[3,4,1],[4,5,1]])\n            sage: Q.mutation_type()\n            ['undetermined finite mutation type', ['A', 3]]\n\n        TESTS::\n\n            sage: Q = ClusterQuiver(matrix([[0, 3], [-1, 0], [1, 0], [0, 1]]))\n            sage: Q.mutation_type()\n            ['G', 2]\n            sage: Q = ClusterQuiver(matrix([[0, -1, -1, 1, 0], [1, 0, 1, 0, 1], [1, -1, 0, -1, 0], [-1, 0, 1, 0, 1], [0, -1, 0, -1, 0], [0, 1, 0, -1, -1], [0, 1, -1, 0, 0]]))\n            sage: Q.mutation_type()\n            'undetermined infinite mutation type'\n        \"\"\"\n        # checking if the mutation type is known already\n        if self._mutation_type is None:\n            # checking mutation type only for the principal part\n            if self._m > 0:\n                dg = self._digraph.subgraph( range(self._n) )\n            else:\n                dg = self._digraph\n\n            # checking the type for each connected component\n            mutation_type = []\n            connected_components = sorted(dg.connected_components())\n            for component in connected_components:\n                # constructing the digraph for this component\n                dg_component = dg.subgraph( component )\n                dg_component.relabel()\n                # turning dg_component into a canonical form\n                iso, orbits = _dg_canonical_form( dg_component, dg_component.num_verts(), 0 )\n                # turning dg_component into a canonical form\n                dig6 = _digraph_to_dig6( dg_component, hashable=True )\n                # and getting the corresponding matrix\n                M = _dig6_to_matrix(dig6)\n\n                # checking if this quiver is mutation infinite\n                is_finite, path = is_mutation_finite(M)\n                if is_finite is False:\n                    mut_type_part = 'undetermined infinite mutation type'\n                else:\n                    # checking if this quiver is in the database\n                    mut_type_part = _mutation_type_from_data( dg_component.order(), dig6, compute_if_necessary=False )\n                    # checking if the algorithm can determine the mutation type\n                    if mut_type_part == 'unknown':\n                        mut_type_part = _connected_mutation_type(dg_component)\n                    # checking if this quiver is of exceptional type by computing the exceptional mutation classes\n                    if mut_type_part == 'unknown':\n                        mut_type_part = _mutation_type_from_data(dg_component.order(), dig6, compute_if_necessary=True)\n                    if mut_type_part == 'unknown':\n                        mut_type_part = 'undetermined finite mutation type'\n                mutation_type.append( mut_type_part )\n\n            # the empty quiver case\n            if len( mutation_type ) == 0:\n                Warning('Quiver has no vertices')\n                mutation_type = None\n            # the connected quiver case\n            elif len( mutation_type ) == 1:\n                mutation_type = mutation_type[0]\n            # the reducible quiver case\n            elif len( mutation_type ) > 1:\n                if any( isinstance(mut_type_part, str) for mut_type_part in mutation_type ):\n                    pass\n                else:\n                    mutation_type = QuiverMutationType( mutation_type )\n            self._mutation_type = mutation_type\n        return self._mutation_type\n\n    def n(self):\n        \"\"\"\n        Returns the number of free vertices of ``self``.\n\n        EXAMPLES::\n\n            sage: ClusterQuiver(['A',4]).n()\n            4\n            sage: ClusterQuiver(['A',(3,1),1]).n()\n            4\n            sage: ClusterQuiver(['B',4]).n()\n            4\n            sage: ClusterQuiver(['B',4,1]).n()\n            5\n        \"\"\"\n        return self._n\n\n    def m(self):\n        \"\"\"\n        Returns the number of frozen vertices of ``self``.\n\n        EXAMPLES::\n\n            sage: Q = ClusterQuiver(['A',4])\n            sage: Q.m()\n            0\n\n            sage: T = ClusterQuiver( Q.digraph().edges(), frozen=1 )\n            sage: T.n()\n            3\n            sage: T.m()\n            1\n        \"\"\"\n        return self._m\n\n    def canonical_label( self, certify=False ):\n        \"\"\"\n        Returns the canonical labelling of ``self``, see sage.graphs.graph.GenericGraph.canonical_label.\n\n        INPUT:\n\n        - ``certify`` -- (default: False) if True, the dictionary from ``self.vertices()`` to the vertices of the returned quiver is returned as well.\n\n        EXAMPLES::\n\n            sage: Q = ClusterQuiver(['A',4]); Q.digraph().edges()\n            [(0, 1, (1, -1)), (2, 1, (1, -1)), (2, 3, (1, -1))]\n\n            sage: T = Q.canonical_label(); T.digraph().edges()\n            [(0, 3, (1, -1)), (1, 2, (1, -1)), (1, 3, (1, -1))]\n\n            sage: T,iso = Q.canonical_label(certify=True); T.digraph().edges(); iso\n            [(0, 3, (1, -1)), (1, 2, (1, -1)), (1, 3, (1, -1))]\n            {0: 0, 1: 3, 2: 1, 3: 2}\n\n            sage: Q = ClusterQuiver(QuiverMutationType([['B',2],['A',1]])); Q\n            Quiver on 3 vertices of type [ ['B', 2], ['A', 1] ]\n\n            sage: Q.canonical_label()\n            Quiver on 3 vertices of type [ ['A', 1], ['B', 2] ]\n\n            sage: Q.canonical_label(certify=True)\n            (Quiver on 3 vertices of type [ ['A', 1], ['B', 2] ], {0: 1, 1: 2, 2: 0})\n        \"\"\"\n        n = self._n\n        m = self._m\n\n        # computing the canonical form respecting the frozen variables\n        dg = copy( self._digraph )\n        iso, orbits = _dg_canonical_form( dg, n, m )\n        Q = ClusterQuiver( dg )\n        # getting the new ordering for the mutation type if necessary\n        if self._mutation_type:\n            if dg.is_connected():\n                Q._mutation_type = self._mutation_type\n            else:\n                CC = sorted( self._digraph.connected_components() )\n                CC_new = sorted( zip( [ sorted( [ iso[i] for i in L ] ) for L in CC ], range( len( CC ) ) ) )\n                comp_iso = [ L[1] for L in CC_new ]\n                Q._mutation_type = []\n                for i in range( len( CC_new ) ):\n                    Q._mutation_type.append( copy( self._mutation_type.irreducible_components()[ comp_iso[i] ] ) )\n                Q._mutation_type = QuiverMutationType( Q._mutation_type )\n        if certify:\n            return Q, iso\n        else:\n            return Q\n\n    def is_acyclic(self):\n        \"\"\"\n        Returns true if ``self`` is acyclic.\n\n        EXAMPLES::\n\n            sage: ClusterQuiver(['A',4]).is_acyclic()\n            True\n\n            sage: ClusterQuiver(['A',[2,1],1]).is_acyclic()\n            True\n\n            sage: ClusterQuiver([[0,1],[1,2],[2,0]]).is_acyclic()\n            False\n        \"\"\"\n        return self._digraph.is_directed_acyclic()\n\n    def is_bipartite(self,return_bipartition=False):\n        \"\"\"\n        Returns true if ``self`` is bipartite.\n\n        EXAMPLES::\n\n            sage: ClusterQuiver(['A',[3,3],1]).is_bipartite()\n            True\n\n            sage: ClusterQuiver(['A',[4,3],1]).is_bipartite()\n            False\n        \"\"\"\n        dg = copy( self._digraph )\n        dg.delete_vertices( range(self._n,self._n+self._m) )\n        innie = dg.in_degree()\n        outie = dg.out_degree()\n        is_bip = sum( [ innie[i]*outie[i] for i in range(len(innie)) ] ) == 0\n        if not is_bip:\n            return False\n        else:\n            if not return_bipartition:\n                return True\n            else:\n                g = dg.to_undirected()\n                return g.bipartite_sets()\n\n    def exchangeable_part(self):\n        \"\"\"\n        Returns the restriction to the principal part (i.e. exchangeable part) of ``self``, the subquiver obtained by deleting the frozen vertices of ``self``.\n\n        EXAMPLES::\n\n            sage: Q = ClusterQuiver(['A',4])\n            sage: T = ClusterQuiver( Q.digraph().edges(), frozen=1 )\n            sage: T.digraph().edges()\n            [(0, 1, (1, -1)), (2, 1, (1, -1)), (2, 3, (1, -1))]\n\n            sage: T.exchangeable_part().digraph().edges()\n            [(0, 1, (1, -1)), (2, 1, (1, -1))]\n\n            sage: Q2 = Q.principal_extension()\n            sage: Q3 = Q2.principal_extension()\n            sage: Q2.exchangeable_part() == Q3.exchangeable_part()\n            True\n        \"\"\"\n        dg = DiGraph( self._digraph )\n        dg.delete_vertices( range(self._n,self._n+self._m) )\n        Q = ClusterQuiver( dg )\n        Q._mutation_type = self._mutation_type\n        return Q\n\n    def principal_extension(self, inplace=False):\n        \"\"\"\n        Returns the principal extension of ``self``, adding n frozen vertices to any previously frozen vertices. I.e., the quiver obtained by adding an outgoing edge to every mutable vertex of ``self``.\n\n        EXAMPLES::\n\n            sage: Q = ClusterQuiver(['A',2]); Q\n            Quiver on 2 vertices of type ['A', 2]\n            sage: T = Q.principal_extension(); T\n            Quiver on 4 vertices of type ['A', 2] with 2 frozen vertices\n            sage: T2 = T.principal_extension(); T2\n            Quiver on 6 vertices of type ['A', 2] with 4 frozen vertices\n            sage: Q.digraph().edges()\n            [(0, 1, (1, -1))]\n            sage: T.digraph().edges()\n            [(0, 1, (1, -1)), (2, 0, (1, -1)), (3, 1, (1, -1))]\n            sage: T2.digraph().edges()\n            [(0, 1, (1, -1)), (2, 0, (1, -1)), (3, 1, (1, -1)), (4, 0, (1, -1)), (5, 1, (1, -1))]\n        \"\"\"\n        dg = DiGraph( self._digraph )\n        dg.add_edges( [(self._n+self._m+i,i) for i in range(self._n)] )\n        Q = ClusterQuiver( dg, frozen=self._m+self._n )\n        Q._mutation_type = self._mutation_type\n        if inplace:\n            self.__init__(Q)\n        else:\n            return Q\n\n    def mutate(self, data, inplace=True):\n        \"\"\"\n        Mutates ``self`` at a sequence of vertices.\n\n        INPUT:\n\n        - ``sequence`` -- a vertex of ``self`` or an iterator of vertices of ``self``.\n        - ``inplace`` -- (default: True) if False, the result is returned, otherwise ``self`` is modified.\n\n        EXAMPLES::\n\n            sage: Q = ClusterQuiver(['A',4]); Q.b_matrix()\n            [ 0  1  0  0]\n            [-1  0 -1  0]\n            [ 0  1  0  1]\n            [ 0  0 -1  0]\n\n            sage: Q.mutate(0); Q.b_matrix()\n            [ 0 -1  0  0]\n            [ 1  0 -1  0]\n            [ 0  1  0  1]\n            [ 0  0 -1  0]\n\n            sage: T = Q.mutate(0, inplace=False); T\n            Quiver on 4 vertices of type ['A', 4]\n\n            sage: Q.mutate(0)\n            sage: Q == T\n            True\n\n            sage: Q.mutate([0,1,0])\n            sage: Q.b_matrix()\n            [ 0 -1  1  0]\n            [ 1  0  0  0]\n            [-1  0  0  1]\n            [ 0  0 -1  0]\n\n            sage: Q = ClusterQuiver(QuiverMutationType([['A',1],['A',3]]))\n            sage: Q.b_matrix()\n            [ 0  0  0  0]\n            [ 0  0  1  0]\n            [ 0 -1  0 -1]\n            [ 0  0  1  0]\n\n            sage: T = Q.mutate(0,inplace=False)\n            sage: Q == T\n            True\n\n        TESTS::\n\n            sage: Q = ClusterQuiver(['A',4]); Q.mutate(0,1)\n            Traceback (most recent call last):\n            ...\n            ValueError: The second parameter must be boolean.  To mutate at a sequence of length 2, input it as a list.\n\n            sage: Q = ClusterQuiver(['A',4]); Q.mutate(0,0)\n            Traceback (most recent call last):\n            ...\n            ValueError: The second parameter must be boolean.  To mutate at a sequence of length 2, input it as a list.\n        \"\"\"\n        n = self._n\n        m = self._m\n        dg = self._digraph\n        V = range(n)\n\n        if data in V:\n            seq = [data]\n        else:\n            seq = data\n        if isinstance(seq, tuple):\n            seq = list( seq )\n        if not isinstance(seq, list):\n            raise ValueError('The quiver can only be mutated at a vertex or at a sequence of vertices')\n        if not isinstance(inplace, bool):\n            raise ValueError('The second parameter must be boolean.  To mutate at a sequence of length 2, input it as a list.')\n        if any( v not in V for v in seq ):\n            v = filter( lambda v: v not in V, seq )[0]\n            raise ValueError('The quiver cannot be mutated at the vertex %s'%v)\n\n        for v in seq:\n            dg = _digraph_mutate( dg, v, n, m )\n        M = _edge_list_to_matrix( dg.edge_iterator(), n, m )\n        if inplace:\n            self._M = M\n            self._digraph = dg\n        else:\n            Q = ClusterQuiver( M )\n            Q._mutation_type = self._mutation_type\n            return Q\n\n    def mutation_sequence(self, sequence, show_sequence=False, fig_size=1.2 ):\n        \"\"\"\n        Returns a list containing the sequence of quivers obtained from ``self`` by a sequence of mutations on vertices.\n\n        INPUT:\n\n        - ``sequence`` -- a list or tuple of vertices of ``self``.\n        - ``show_sequence`` -- (default: False) if True, a png containing the mutation sequence is shown.\n        - ``fig_size`` -- (default: 1.2) factor by which the size of the sequence is expanded.\n\n        EXAMPLES::\n\n            sage: Q = ClusterQuiver(['A',4])\n            sage: seq = Q.mutation_sequence([0,1]); seq\n            [Quiver on 4 vertices of type ['A', 4], Quiver on 4 vertices of type ['A', 4], Quiver on 4 vertices of type ['A', 4]]\n            sage: [T.b_matrix() for T in seq]\n            [\n            [ 0  1  0  0]  [ 0 -1  0  0]  [ 0  1 -1  0]\n            [-1  0 -1  0]  [ 1  0 -1  0]  [-1  0  1  0]\n            [ 0  1  0  1]  [ 0  1  0  1]  [ 1 -1  0  1]\n            [ 0  0 -1  0], [ 0  0 -1  0], [ 0  0 -1  0]\n            ]\n        \"\"\"\n        from sage.plot.plot import Graphics\n        from sage.plot.text import text\n        n = self._n\n        m = self._m\n        if m == 0:\n            width_factor = 3\n            fig_size = fig_size*2*n/3\n        else:\n            width_factor = 6\n            fig_size = fig_size*4*n/3\n        V = range(n)\n\n        if isinstance(sequence, tuple):\n            sequence = list( sequence )\n        if not isinstance(sequence, list):\n            raise ValueError('The quiver can only be mutated at a vertex or at a sequence of vertices')\n        if any( v not in V for v in sequence ):\n            v = filter( lambda v: v not in V, sequence )[0]\n            raise ValueError('The quiver can only be mutated at the vertex %s'%v )\n\n        quiver = copy( self )\n        quiver_sequence = []\n        quiver_sequence.append( copy( quiver ) )\n\n        for v in sequence:\n            quiver.mutate( v )\n            quiver_sequence.append( copy( quiver ) )\n\n        if show_sequence:\n            def _plot_arrow( v, k, center=(0,0) ):\n                return text(\"$\\longleftrightarrow$\",(center[0],center[1]), fontsize=25) + text(\"$\\mu_\"+str(v)+\"$\",(center[0],center[1]+0.15), fontsize=15) \\\n                    + text(\"$\"+str(k)+\"$\",(center[0],center[1]-0.2), fontsize=15)\n            plot_sequence = [ quiver_sequence[i].plot( circular=True, center=(i*width_factor,0) ) for i in range(len(quiver_sequence)) ]\n            arrow_sequence = [ _plot_arrow( sequence[i],i+1,center=((i+0.5)*width_factor,0) ) for i in range(len(sequence)) ]\n            sequence = []\n            for i in xrange( len( plot_sequence ) ):\n                if i < len( arrow_sequence ):\n                    sequence.append( plot_sequence[i] + arrow_sequence[i] )\n                else:\n                    sequence.append( plot_sequence[i] )\n            plot_obj = Graphics()\n            for elem in sequence:\n                plot_obj += elem\n            plot_obj.show(axes=False, figsize=[fig_size*len(quiver_sequence),fig_size])\n        return quiver_sequence\n\n    def reorient( self, data ):\n        \"\"\"\n        Reorients ``self`` with respect to the given total order, or with respect to an iterator of edges in ``self`` to be reverted.\n\n        WARNING::\n\n            This operation might change the mutation type of ``self``.\n\n        INPUT:\n\n        - ``data`` -- an iterator defining a total order on ``self.vertices()``, or an iterator of edges in ``self`` to be reoriented.\n\n        EXAMPLES::\n\n            sage: Q = ClusterQuiver(['A',(2,3),1])\n            sage: Q.mutation_type()\n            ['A', [2, 3], 1]\n\n            sage: Q.reorient([(0,1),(1,2),(2,3),(3,4)])\n            sage: Q.mutation_type()\n            ['D', 5]\n\n            sage: Q.reorient([0,1,2,3,4])\n            sage: Q.mutation_type()\n            ['A', [1, 4], 1]\n        \"\"\"\n        if all( 0 <= i and i < self._n + self._m for i in data ) and len( set( data ) ) == self._n+self._m :\n            dg_new = DiGraph()\n            for edge in self._digraph.edges():\n                if data.index( edge[0] ) < data.index( edge[1] ):\n                    dg_new.add_edge( edge[0],edge[1],edge[2] )\n                else:\n                    dg_new.add_edge( edge[1],edge[0],edge[2] )\n            self._digraph = dg_new\n            self._M = _edge_list_to_matrix( dg_new.edges(), self._n, self._m )\n            self._mutation_type = None\n        elif all( type(edge) in [list,tuple] and len(edge)==2 for edge in data ):\n            edges = self._digraph.edges(labels=False)\n            for edge in data:\n                if (edge[1],edge[0]) in edges:\n                    label = self._digraph.edge_label(edge[1],edge[0])\n                    self._digraph.delete_edge(edge[1],edge[0])\n                    self._digraph.add_edge(edge[0],edge[1],label)\n            self._M = _edge_list_to_matrix( self._digraph.edges(), self._n, self._m )\n            self._mutation_type = None\n        else:\n            raise ValueError('The order is no total order on the vertices of the quiver or a list of edges to be oriented.')\n\n    def mutation_class_iter( self, depth=infinity, show_depth=False, return_paths=False, data_type=\"quiver\", up_to_equivalence=True, sink_source=False ):\n        \"\"\"\n        Returns an iterator for the mutation class of self together with certain constrains.\n\n        INPUT:\n\n        - ``depth`` -- (default: infinity) integer, only quivers with distance at most depth from self are returned.\n        - ``show_depth`` -- (default: False) if True, the actual depth of the mutation is shown.\n        - ``return_paths`` -- (default: False) if True, a shortest path of mutation sequences from self to the given quiver is returned as well.\n        - ``data_type`` -- (default: \"quiver\") can be one of the following::\n\n            * \"quiver\"\n            * \"matrix\"\n            * \"digraph\"\n            * \"dig6\"\n            * \"path\"\n\n        - ``up_to_equivalence`` -- (default: True) if True, only one quiver for each graph-isomorphism class is recorded.\n        - ``sink_source`` -- (default: False) if True, only mutations at sinks and sources are applied.\n\n        EXAMPLES::\n\n            sage: Q = ClusterQuiver(['A',3])\n            sage: it = Q.mutation_class_iter()\n            sage: for T in it: print T\n            Quiver on 3 vertices of type ['A', 3]\n            Quiver on 3 vertices of type ['A', 3]\n            Quiver on 3 vertices of type ['A', 3]\n            Quiver on 3 vertices of type ['A', 3]\n\n            sage: it = Q.mutation_class_iter(depth=1)\n            sage: for T in it: print T\n            Quiver on 3 vertices of type ['A', 3]\n            Quiver on 3 vertices of type ['A', 3]\n            Quiver on 3 vertices of type ['A', 3]\n\n            sage: it = Q.mutation_class_iter(show_depth=True)\n            sage: for T in it: pass\n            Depth: 0     found: 1          Time: ... s\n            Depth: 1     found: 3          Time: ... s\n            Depth: 2     found: 4          Time: ... s\n\n            sage: it = Q.mutation_class_iter(return_paths=True)\n            sage: for T in it: print T\n            (Quiver on 3 vertices of type ['A', 3], [])\n            (Quiver on 3 vertices of type ['A', 3], [1])\n            (Quiver on 3 vertices of type ['A', 3], [0])\n            (Quiver on 3 vertices of type ['A', 3], [0, 1])\n\n            sage: it = Q.mutation_class_iter(up_to_equivalence=False)\n            sage: for T in it: print T\n            Quiver on 3 vertices of type ['A', 3]\n            Quiver on 3 vertices of type ['A', 3]\n            Quiver on 3 vertices of type ['A', 3]\n            Quiver on 3 vertices of type ['A', 3]\n            Quiver on 3 vertices of type ['A', 3]\n            Quiver on 3 vertices of type ['A', 3]\n            Quiver on 3 vertices of type ['A', 3]\n            Quiver on 3 vertices of type ['A', 3]\n            Quiver on 3 vertices of type ['A', 3]\n            Quiver on 3 vertices of type ['A', 3]\n            Quiver on 3 vertices of type ['A', 3]\n            Quiver on 3 vertices of type ['A', 3]\n            Quiver on 3 vertices of type ['A', 3]\n            Quiver on 3 vertices of type ['A', 3]\n\n            sage: it = Q.mutation_class_iter(return_paths=True,up_to_equivalence=False)\n            sage: for T in it: print T\n            (Quiver on 3 vertices of type ['A', 3], [])\n            (Quiver on 3 vertices of type ['A', 3], [2])\n            (Quiver on 3 vertices of type ['A', 3], [1])\n            (Quiver on 3 vertices of type ['A', 3], [0])\n            (Quiver on 3 vertices of type ['A', 3], [2, 1])\n            (Quiver on 3 vertices of type ['A', 3], [0, 1])\n            (Quiver on 3 vertices of type ['A', 3], [0, 1, 2])\n            (Quiver on 3 vertices of type ['A', 3], [0, 1, 0])\n            (Quiver on 3 vertices of type ['A', 3], [2, 1, 2])\n            (Quiver on 3 vertices of type ['A', 3], [2, 1, 0])\n            (Quiver on 3 vertices of type ['A', 3], [2, 1, 0, 2])\n            (Quiver on 3 vertices of type ['A', 3], [2, 1, 0, 1])\n            (Quiver on 3 vertices of type ['A', 3], [2, 1, 2, 1])\n            (Quiver on 3 vertices of type ['A', 3], [2, 1, 2, 0])\n\n            sage: Q = ClusterQuiver(['A',3])\n            sage: it = Q.mutation_class_iter(data_type='path')\n            sage: for T in it: print T\n            []\n            [1]\n            [0]\n            [0, 1]\n\n            sage: Q = ClusterQuiver(['A',3])\n            sage: it = Q.mutation_class_iter(return_paths=True,data_type='matrix')\n            sage: next(it)\n            (\n            [ 0  0  1]\n            [ 0  0  1]\n            [-1 -1  0], []\n            )\n\n        \"\"\"\n        if data_type == 'path':\n            return_paths = False\n        if data_type == \"dig6\":\n            return_dig6 = True\n        else:\n            return_dig6 = False\n        dg = DiGraph( self._digraph )\n        MC_iter = _mutation_class_iter( dg, self._n, self._m, depth=depth, return_dig6=return_dig6, show_depth=show_depth, up_to_equivalence=up_to_equivalence, sink_source=sink_source )\n        for data in MC_iter:\n            if data_type == \"quiver\":\n                next_element = ClusterQuiver( data[0], frozen=self._m )\n                next_element._mutation_type = self._mutation_type\n            elif data_type == \"matrix\":\n                next_element = ClusterQuiver( data[0], frozen=self._m )._M\n            elif data_type == \"digraph\":\n                next_element = data[0]\n            elif data_type == \"dig6\":\n                next_element = data[0]\n            elif data_type == \"path\":\n                next_element = data[1]\n            else:\n                raise ValueError(\"The parameter for data_type was \"\n                                 \"not recognized.\")\n            if return_paths:\n                yield (next_element, data[1])\n            else:\n                yield next_element\n\n    def mutation_class( self, depth=infinity, show_depth=False, return_paths=False, data_type=\"quiver\", up_to_equivalence=True, sink_source=False ):\n        \"\"\"\n        Returns the mutation class of self together with certain constrains.\n\n        INPUT:\n\n        - ``depth`` -- (default: infinity) integer, only seeds with distance at most depth from self are returned.\n        - ``show_depth`` -- (default: False) if True, the actual depth of the mutation is shown.\n        - ``return_paths`` -- (default: False) if True, a shortest path of mutation sequences from self to the given quiver is returned as well.\n        - ``data_type`` -- (default: \"quiver\") can be one of the following::\n\n            * \"quiver\" -- the quiver is returned\n            * \"dig6\" -- the dig6-data is returned\n            * \"path\" -- shortest paths of mutation sequences from self are returned\n\n        - ``sink_source`` -- (default: False) if True, only mutations at sinks and sources are applied.\n\n        EXAMPLES::\n\n            sage: Q = ClusterQuiver(['A',3])\n            sage: Ts = Q.mutation_class()\n            sage: for T in Ts: print T\n            Quiver on 3 vertices of type ['A', 3]\n            Quiver on 3 vertices of type ['A', 3]\n            Quiver on 3 vertices of type ['A', 3]\n            Quiver on 3 vertices of type ['A', 3]\n\n            sage: Ts = Q.mutation_class(depth=1)\n            sage: for T in Ts: print T\n            Quiver on 3 vertices of type ['A', 3]\n            Quiver on 3 vertices of type ['A', 3]\n            Quiver on 3 vertices of type ['A', 3]\n\n            sage: Ts = Q.mutation_class(show_depth=True)\n            Depth: 0     found: 1          Time: ... s\n            Depth: 1     found: 3          Time: ... s\n            Depth: 2     found: 4          Time: ... s\n\n            sage: Ts = Q.mutation_class(return_paths=True)\n            sage: for T in Ts: print T\n            (Quiver on 3 vertices of type ['A', 3], [])\n            (Quiver on 3 vertices of type ['A', 3], [1])\n            (Quiver on 3 vertices of type ['A', 3], [0])\n            (Quiver on 3 vertices of type ['A', 3], [0, 1])\n\n            sage: Ts = Q.mutation_class(up_to_equivalence=False)\n            sage: for T in Ts: print T\n            Quiver on 3 vertices of type ['A', 3]\n            Quiver on 3 vertices of type ['A', 3]\n            Quiver on 3 vertices of type ['A', 3]\n            Quiver on 3 vertices of type ['A', 3]\n            Quiver on 3 vertices of type ['A', 3]\n            Quiver on 3 vertices of type ['A', 3]\n            Quiver on 3 vertices of type ['A', 3]\n            Quiver on 3 vertices of type ['A', 3]\n            Quiver on 3 vertices of type ['A', 3]\n            Quiver on 3 vertices of type ['A', 3]\n            Quiver on 3 vertices of type ['A', 3]\n            Quiver on 3 vertices of type ['A', 3]\n            Quiver on 3 vertices of type ['A', 3]\n            Quiver on 3 vertices of type ['A', 3]\n\n            sage: Ts = Q.mutation_class(return_paths=True,up_to_equivalence=False)\n            sage: for T in Ts: print T\n            (Quiver on 3 vertices of type ['A', 3], [])\n            (Quiver on 3 vertices of type ['A', 3], [2])\n            (Quiver on 3 vertices of type ['A', 3], [1])\n            (Quiver on 3 vertices of type ['A', 3], [0])\n            (Quiver on 3 vertices of type ['A', 3], [2, 1])\n            (Quiver on 3 vertices of type ['A', 3], [0, 1])\n            (Quiver on 3 vertices of type ['A', 3], [0, 1, 2])\n            (Quiver on 3 vertices of type ['A', 3], [0, 1, 0])\n            (Quiver on 3 vertices of type ['A', 3], [2, 1, 2])\n            (Quiver on 3 vertices of type ['A', 3], [2, 1, 0])\n            (Quiver on 3 vertices of type ['A', 3], [2, 1, 0, 2])\n            (Quiver on 3 vertices of type ['A', 3], [2, 1, 0, 1])\n            (Quiver on 3 vertices of type ['A', 3], [2, 1, 2, 1])\n            (Quiver on 3 vertices of type ['A', 3], [2, 1, 2, 0])\n\n            sage: Ts = Q.mutation_class(show_depth=True)\n            Depth: 0     found: 1          Time: ... s\n            Depth: 1     found: 3          Time: ... s\n            Depth: 2     found: 4          Time: ... s\n\n            sage: Ts = Q.mutation_class(show_depth=True, up_to_equivalence=False)\n            Depth: 0     found: 1          Time: ... s\n            Depth: 1     found: 4          Time: ... s\n            Depth: 2     found: 6          Time: ... s\n            Depth: 3     found: 10        Time: ... s\n            Depth: 4     found: 14        Time: ... s\n\n        TESTS::\n\n            sage: all( len(ClusterQuiver(['A',n]).mutation_class()) == ClusterQuiver(['A',n]).mutation_type().class_size() for n in [2..6])\n            True\n\n            sage: all( len(ClusterQuiver(['B',n]).mutation_class()) == ClusterQuiver(['B',n]).mutation_type().class_size() for n in [2..6])\n            True\n        \"\"\"\n        if depth is infinity and not self.is_mutation_finite():\n            raise ValueError('The mutation class can - for infinite mutation types - only be computed up to a given depth')\n        return [ Q for Q in self.mutation_class_iter( depth=depth, show_depth=show_depth, return_paths=return_paths, data_type=data_type, up_to_equivalence=up_to_equivalence, sink_source=sink_source ) ]\n\n    def is_finite( self ):\n        \"\"\"\n        Returns True if self is of finite type.\n\n        EXAMPLES::\n\n            sage: Q = ClusterQuiver(['A',3])\n            sage: Q.is_finite()\n            True\n            sage: Q = ClusterQuiver(['A',[2,2],1])\n            sage: Q.is_finite()\n            False\n            sage: Q = ClusterQuiver([['A',3],['B',3]])\n            sage: Q.is_finite()\n            True\n            sage: Q = ClusterQuiver(['T',[4,4,4]])\n            sage: Q.is_finite()\n            False\n            sage: Q = ClusterQuiver([['A',3],['T',[4,4,4]]])\n            sage: Q.is_finite()\n            False\n            sage: Q = ClusterQuiver([['A',3],['T',[2,2,3]]])\n            sage: Q.is_finite()\n            True\n            sage: Q = ClusterQuiver([['A',3],['D',5]])\n            sage: Q.is_finite()\n            True\n            sage: Q = ClusterQuiver([['A',3],['D',5,1]])\n            sage: Q.is_finite()\n            False\n\n            sage: Q = ClusterQuiver([[0,1,2],[1,2,2],[2,0,2]])\n            sage: Q.is_finite()\n            False\n\n            sage: Q = ClusterQuiver([[0,1,2],[1,2,2],[2,0,2],[3,4,1],[4,5,1]])\n            sage: Q.is_finite()\n            False\n        \"\"\"\n        mt = self.mutation_type()\n        if type( mt ) in [QuiverMutationType_Irreducible, QuiverMutationType_Reducible] and mt.is_finite():\n            return True\n        else:\n            return False\n\n    def is_mutation_finite( self, nr_of_checks=None, return_path=False ):\n        \"\"\"\n        Uses a non-deterministic method by random mutations in various directions. Can result in a wrong answer.\n\n        INPUT:\n\n        - ``nr_of_checks`` -- (default: None) number of mutations applied. Standard is 500*(number of vertices of self).\n        - ``return_path`` -- (default: False) if True, in case of self not being mutation finite, a path from self to a quiver with an edge label (a,-b) and a*b > 4 is returned.\n\n        ALGORITHM:\n\n        A quiver is mutation infinite if and only if every edge label (a,-b) satisfy a*b > 4.\n        Thus, we apply random mutations in random directions\n\n        EXAMPLES::\n\n            sage: Q = ClusterQuiver(['A',10])\n            sage: Q._mutation_type = None\n            sage: Q.is_mutation_finite()\n            True\n\n            sage: Q = ClusterQuiver([(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(2,9)])\n            sage: Q.is_mutation_finite()\n            False\n        \"\"\"\n        if self._n <= 2:\n            is_finite = True\n            path = None\n        elif not return_path and self._mutation_type == 'undetermined infinite mutation type':\n            is_finite = False\n        elif type( self._mutation_type ) in [QuiverMutationType_Irreducible, QuiverMutationType_Reducible] and self._mutation_type.is_mutation_finite():\n            is_finite = True\n            path = None\n        elif not return_path and type( self._mutation_type ) in [QuiverMutationType_Irreducible, QuiverMutationType_Reducible] and not self._mutation_type.is_mutation_finite():\n            is_finite = False\n        else:\n            # turning dg_component into a canonical form\n            dig6 = _digraph_to_dig6(self.digraph())\n            # and getting the corresponding matrix\n            M = _dig6_to_matrix(dig6)\n\n            is_finite, path = is_mutation_finite(M,nr_of_checks=nr_of_checks)\n        if return_path:\n            return is_finite, path\n        else:\n            return is_finite\n","mode":"python","lineno":-1,"filename":null}}︡
︠f4d95383-487d-4301-bdf0-514329d5d50bo︠

︠a431a43c-76de-4d62-8b7b-8c8881336b7eos︠
ClusterSeed??
︡872832d3-b013-4b2c-bc26-907d85197d80︡{"code":{"source":"   File: /projects/sage/sage-6.7/src/sage/misc/lazy_import.pyx\n   Source:\n   class ClusterSeed(SageObject):\n    r\"\"\"\n    The *cluster seed* associated to an *exchange matrix*.\n\n    INPUT:\n\n    - ``data`` -- can be any of the following::\n\n        * QuiverMutationType\n        * str - a string representing a QuiverMutationType or a common quiver type (see Examples)\n        * ClusterQuiver\n        * Matrix - a skew-symmetrizable matrix\n        * DiGraph - must be the input data for a quiver\n        * List of edges - must be the edge list of a digraph for a quiver\n\n    EXAMPLES::\n\n        sage: S = ClusterSeed(['A',5]); S\n        A seed for a cluster algebra of rank 5 of type ['A', 5]\n\n        sage: S = ClusterSeed(['A',[2,5],1]); S\n        A seed for a cluster algebra of rank 7 of type ['A', [2, 5], 1]\n\n        sage: T = ClusterSeed( S ); T\n        A seed for a cluster algebra of rank 7 of type ['A', [2, 5], 1]\n\n        sage: T = ClusterSeed( S._M ); T\n        A seed for a cluster algebra of rank 7\n\n        sage: T = ClusterSeed( S.quiver()._digraph ); T\n        A seed for a cluster algebra of rank 7\n\n        sage: T = ClusterSeed( S.quiver()._digraph.edges() ); T\n        A seed for a cluster algebra of rank 7\n\n        sage: S = ClusterSeed(['B',2]); S\n        A seed for a cluster algebra of rank 2 of type ['B', 2]\n\n        sage: S = ClusterSeed(['C',2]); S\n        A seed for a cluster algebra of rank 2 of type ['B', 2]\n\n        sage: S = ClusterSeed(['A', [5,0],1]); S\n        A seed for a cluster algebra of rank 5 of type ['D', 5]\n\n        sage: S = ClusterSeed(['GR',[3,7]]); S\n        A seed for a cluster algebra of rank 6 of type ['E', 6]\n\n        sage: S = ClusterSeed(['F', 4, [2,1]]); S\n        A seed for a cluster algebra of rank 6 of type ['F', 4, [1, 2]]\n    \"\"\"\n    def __init__(self, data, frozen=None, is_principal=None):\n        r\"\"\"\n        TESTS::\n\n            sage: S = ClusterSeed(['A',4])\n            sage: TestSuite(S).run()\n        \"\"\"\n        from quiver import ClusterQuiver\n\n        # constructs a cluster seed from a cluster seed\n        if isinstance(data, ClusterSeed):\n            if frozen:\n                print \"The input \\'frozen\\' is ignored\"\n            self._M = copy( data._M )\n            self._cluster = copy(data._cluster)\n            self._n = data._n\n            self._m = data._m\n            self._R = data._R\n            self._quiver = ClusterQuiver( data._quiver ) if data._quiver else None\n            self._mutation_type = copy( data._mutation_type )\n            self._description = copy( data._description )\n            self._is_principal = data._is_principal\n\n        # constructs a cluster seed from a quiver\n        elif isinstance(data, ClusterQuiver):\n            if frozen:\n                print \"The input \\'frozen\\' is ignored\"\n\n            quiver = ClusterQuiver( data )\n            self._M = copy(quiver._M)\n            self._n = quiver._n\n            self._m = quiver._m\n            self._quiver = quiver\n            self._mutation_type = quiver._mutation_type\n            self._description = 'A seed for a cluster algebra of rank %d' %(self._n)\n            self._R = FractionField(PolynomialRing(QQ,['x%s'%i for i in range(0,self._n)]+['y%s'%i for i in range(0,self._m)]))\n            self._cluster = list(self._R.gens())\n            self._is_principal = None\n\n        # in all other cases, we construct the corresponding ClusterQuiver first\n        else:\n            quiver = ClusterQuiver( data, frozen=frozen )\n            self.__init__( quiver )\n\n        if is_principal is not None:\n            self._is_principal = is_principal\n\n    def __eq__(self, other):\n        r\"\"\"\n        Returns True iff ``self`` represent the same cluster seed as ``other``.\n\n        EXAMPLES::\n\n            sage: S = ClusterSeed(['A',5])\n            sage: T = S.mutate( 2, inplace=False )\n            sage: S.__eq__( T )\n            False\n\n            sage: T.mutate( 2 )\n            sage: S.__eq__( T )\n            True\n        \"\"\"\n        return isinstance(other, ClusterSeed) and self._M == other._M and self._cluster == other._cluster\n\n    def _repr_(self):\n        r\"\"\"\n        Returns the description of ``self``.\n\n        EXAMPLES::\n\n            sage: S = ClusterSeed(['A',5])\n            sage: S._repr_()\n            \"A seed for a cluster algebra of rank 5 of type ['A', 5]\"\n\n            sage: S=ClusterSeed(['B',2])\n            sage: T=S.principal_extension()\n            sage: T._repr_()\n            \"A seed for a cluster algebra of rank 2 of type ['B', 2] with principal coefficients\"\n        \"\"\"\n        name = self._description\n        if self._mutation_type:\n            if type( self._mutation_type ) in [QuiverMutationType_Irreducible,QuiverMutationType_Reducible]:\n                name += ' of type ' + str(self._mutation_type)\n            # the following case allows description of 'undetermined finite mutation type'\n            else:\n                name += ' of ' + self._mutation_type\n        if self._is_principal:\n            name += ' with principal coefficients'\n        elif self._m == 1:\n            name += ' with %s frozen variable'%self._m\n        elif self._m > 1:\n            name += ' with %s frozen variables'%self._m\n        return name\n\n    def plot(self, circular=False, mark=None, save_pos=False):\n        r\"\"\"\n        Returns the plot of the quiver of ``self``.\n\n        INPUT:\n\n        - ``circular`` -- (default:False) if True, the circular plot is chosen, otherwise >>spring<< is used.\n        - ``mark`` -- (default: None) if set to i, the vertex i is highlighted.\n        - ``save_pos`` -- (default:False) if True, the positions of the vertices are saved.\n\n        EXAMPLES::\n\n            sage: S = ClusterSeed(['A',5])\n            sage: pl = S.plot()\n            sage: pl = S.plot(circular=True)\n        \"\"\"\n        return self.quiver().plot(circular=circular,mark=mark,save_pos=save_pos)\n\n    def show(self, fig_size=1, circular=False, mark=None, save_pos=False):\n        r\"\"\"\n        Shows the plot of the quiver of ``self``.\n\n        INPUT:\n\n        - ``fig_size`` -- (default: 1) factor by which the size of the plot is multiplied.\n        - ``circular`` -- (default: False) if True, the circular plot is chosen, otherwise >>spring<< is used.\n        - ``mark`` -- (default: None) if set to i, the vertex i is highlighted.\n        - ``save_pos`` -- (default:False) if True, the positions of the vertices are saved.\n\n        TESTS::\n\n            sage: S = ClusterSeed(['A',5])\n            sage: S.show() # long time\n        \"\"\"\n        self.quiver().show(fig_size=fig_size, circular=circular,mark=mark,save_pos=save_pos)\n\n    def interact(self, fig_size=1, circular=True):\n        r\"\"\"\n        Only in *notebook mode*. Starts an interactive window for cluster seed mutations.\n\n        INPUT:\n\n        - ``fig_size`` -- (default: 1) factor by which the size of the plot is multiplied.\n        - ``circular`` -- (default: True) if True, the circular plot is chosen, otherwise >>spring<< is used.\n\n        TESTS::\n\n            sage: S = ClusterSeed(['A',4])\n            sage: S.interact() # long time\n            'The interactive mode only runs in the Sage notebook.'\n        \"\"\"\n        from sage.plot.plot import EMBEDDED_MODE\n        from sagenb.notebook.interact import interact, selector\n        from sage.misc.all import html,latex\n\n        if not EMBEDDED_MODE:\n            return \"The interactive mode only runs in the Sage notebook.\"\n        else:\n            seq = []\n            sft = [True]\n            sss = [True]\n            ssv = [True]\n            ssm = [True]\n            ssl = [True]\n            @interact\n            def player(k=selector(values=range(self._n),nrows = 1,label='Mutate at: '), show_seq=(\"Mutation sequence:\", True), show_vars=(\"Cluster variables:\", True), show_matrix=(\"B-Matrix:\", True), show_lastmutation=(\"Show last mutation:\", True) ):\n                ft,ss,sv,sm,sl = sft.pop(), sss.pop(), ssv.pop(), ssm.pop(), ssl.pop()\n                if ft:\n                    self.show(fig_size=fig_size, circular=circular)\n                elif show_seq is not ss or show_vars is not sv or show_matrix is not sm or show_lastmutation is not sl:\n                    if seq and show_lastmutation:\n                        self.show(fig_size=fig_size, circular=circular, mark=seq[len(seq)-1])\n                    else:\n                        self.show(fig_size=fig_size, circular=circular )\n                else:\n                    self.mutate(k)\n                    seq.append(k)\n                    if not show_lastmutation:\n                        self.show(fig_size=fig_size, circular=circular)\n                    else:\n                        self.show(fig_size=fig_size, circular=circular,mark=k)\n                sft.append(False)\n                sss.append(show_seq)\n                ssv.append(show_vars)\n                ssm.append(show_matrix)\n                ssl.append(show_lastmutation)\n                if show_seq: html( \"Mutation sequence: $\" + str( [ seq[i] for i in xrange(len(seq)) ] ).strip('[]') + \"$\" )\n                if show_vars:\n                    html( \"Cluster variables:\" )\n                    table = \"$\\\\begin{align*}\\n\"\n                    for i in xrange(self._n):\n                        table += \"\\tv_{%s} &= \"%i + latex( self._cluster[i] ) + \"\\\\\\\\ \\\\\\\\\\n\"\n                    table += \"\\\\end{align*}$\"\n                    html( \"$ $\" )\n                    html( table )\n                    html( \"$ $\" )\n                if show_matrix:\n                    html( \"B-Matrix:\" )\n                    m = self._M\n                    #m = matrix(range(1,self._n+1),sparse=True).stack(m)\n                    m = latex(m)\n                    m = m.split('(')[1].split('\\\\right')[0]\n                    html( \"$ $\" )\n                    html( \"$\\\\begin{align*} \" + m + \"\\\\end{align*}$\" )\n                    #html( \"$\" + m + \"$\" )\n                    html( \"$ $\" )\n\n    def save_image(self, filename, circular=False, mark=None, save_pos=False):\n        r\"\"\"\n        Saves the plot of the underlying digraph of the quiver of ``self``.\n\n        INPUT:\n\n        - ``filename`` -- the filename the image is saved to.\n        - ``circular`` -- (default: False) if True, the circular plot is chosen, otherwise >>spring<< is used.\n        - ``mark`` -- (default: None) if set to i, the vertex i is highlighted.\n        - ``save_pos`` -- (default:False) if True, the positions of the vertices are saved.\n\n        EXAMPLES::\n\n            sage: S = ClusterSeed(['F',4,[1,2]])\n            sage: S.save_image(os.path.join(SAGE_TMP, 'sage.png'))\n        \"\"\"\n        graph_plot = self.plot( circular=circular, mark=mark, save_pos=save_pos)\n        graph_plot.save( filename=filename )\n\n    def b_matrix(self):\n        r\"\"\"\n        Returns the `B` *-matrix* of ``self``.\n\n        EXAMPLES::\n\n            sage: ClusterSeed(['A',4]).b_matrix()\n            [ 0  1  0  0]\n            [-1  0 -1  0]\n            [ 0  1  0  1]\n            [ 0  0 -1  0]\n\n            sage: ClusterSeed(['B',4]).b_matrix()\n            [ 0  1  0  0]\n            [-1  0 -1  0]\n            [ 0  1  0  1]\n            [ 0  0 -2  0]\n\n            sage: ClusterSeed(['D',4]).b_matrix()\n            [ 0  1  0  0]\n            [-1  0 -1 -1]\n            [ 0  1  0  0]\n            [ 0  1  0  0]\n\n            sage: ClusterSeed(QuiverMutationType([['A',2],['B',2]])).b_matrix()\n            [ 0  1  0  0]\n            [-1  0  0  0]\n            [ 0  0  0  1]\n            [ 0  0 -2  0]\n        \"\"\"\n        return copy( self._M )\n\n    def ground_field(self):\n        r\"\"\"\n        Returns the *ground field* of the cluster of ``self``.\n\n        EXAMPLES::\n\n            sage: S = ClusterSeed(['A',3])\n            sage: S.ground_field()\n            Fraction Field of Multivariate Polynomial Ring in x0, x1, x2 over Rational Field\n        \"\"\"\n        return self._R\n\n    def x(self,k):\n        r\"\"\"\n        Returns the `k` *-th initial cluster variable* for the associated cluster seed.\n\n        EXAMPLES::\n\n            sage: S = ClusterSeed(['A',3])\n            sage: S.mutate([2,1])\n            sage: S.x(0)\n            x0\n\n            sage: S.x(1)\n            x1\n\n            sage: S.x(2)\n            x2\n        \"\"\"\n        if k in range(self._n):\n            x = self._R.gens()[k]\n            return ClusterVariable( x.parent(), x.numerator(), x.denominator(), mutation_type=self._mutation_type, variable_type='cluster variable' )\n        else:\n            raise ValueError(\"The input is not in an index of a cluster variable.\")\n\n    def y(self,k):\n        r\"\"\"\n        Returns the `k` *-th initial coefficient (frozen variable)* for the associated cluster seed.\n\n        EXAMPLES::\n\n            sage: S = ClusterSeed(['A',3]).principal_extension()\n            sage: S.mutate([2,1])\n            sage: S.y(0)\n            y0\n\n            sage: S.y(1)\n            y1\n\n            sage: S.y(2)\n            y2\n        \"\"\"\n        if k in range(self._m):\n            x = self._R.gens()[self._n+k]\n            return ClusterVariable( x.parent(), x.numerator(), x.denominator(), mutation_type=self._mutation_type, variable_type='frozen variable' )\n        else:\n            raise ValueError(\"The input is not in an index of a frozen variable.\")\n\n    def n(self):\n        r\"\"\"\n        Returns the number of *exchangeable variables* of ``self``.\n\n        EXAMPLES::\n\n            sage: S = ClusterSeed(['A',3])\n            sage: S.n()\n            3\n        \"\"\"\n        return self._n\n\n    def m(self):\n        r\"\"\"\n        Returns the number of *frozen variables* of ``self``.\n\n        EXAMPLES::\n\n            sage: S = ClusterSeed(['A',3])\n            sage: S.n()\n            3\n\n            sage: S.m()\n            0\n\n            sage: S = S.principal_extension()\n            sage: S.m()\n            3\n        \"\"\"\n        return self._m\n\n    def cluster_variable(self,k):\n        r\"\"\"\n        Returns the `k`-th *cluster variable* of ``self``.\n\n        EXAMPLES::\n\n            sage: S = ClusterSeed(['A',3])\n            sage: S.mutate([1,2])\n\n            sage: [S.cluster_variable(k) for k in range(3)]\n            [x0, (x0*x2 + 1)/x1, (x0*x2 + x1 + 1)/(x1*x2)]\n        \"\"\"\n        if k not in range(self._n):\n            raise ValueError(\"The cluster seed does not have a cluster variable of index %s.\"%k)\n        f = self._cluster[k]\n        return ClusterVariable( f.parent(), f.numerator(), f.denominator(), mutation_type=self._mutation_type, variable_type='cluster variable' )\n\n    def cluster(self):\n        r\"\"\"\n        Returns the *cluster* of ``self``.\n\n        EXAMPLES::\n\n            sage: S = ClusterSeed(['A',3])\n            sage: S.cluster()\n            [x0, x1, x2]\n\n            sage: S.mutate(1)\n            sage: S.cluster()\n            [x0, (x0*x2 + 1)/x1, x2]\n\n            sage: S.mutate(2)\n            sage: S.cluster()\n            [x0, (x0*x2 + 1)/x1, (x0*x2 + x1 + 1)/(x1*x2)]\n\n            sage: S.mutate([2,1])\n            sage: S.cluster()\n            [x0, x1, x2]\n        \"\"\"\n        return [ self.cluster_variable(k) for k in range(self._n) ]\n\n    def f_polynomial(self,k,ignore_coefficients=False):\n        r\"\"\"\n        Returns the ``k``-th *F-polynomial* of ``self``. It is obtained from the\n        ``k``-th cluster variable by setting all `x_i` to `1`.\n\n        Requires principal coefficients, initialized by using principal_extension(),\n        or the user can set 'ignore_coefficients=True' to bypass this restriction.\n\n        Warning: this method assumes the sign-coherence conjecture and that the\n        input seed is sign-coherent (has an exchange matrix with columns of like signs).\n        Otherwise, computational errors might arise.\n\n        EXAMPLES::\n\n            sage: S = ClusterSeed(['A',3]).principal_extension()\n            sage: S.mutate([2,1,2])\n            sage: [S.f_polynomial(k) for k in range(3)]\n            [1, y1*y2 + y2 + 1, y1 + 1]\n\n            sage: S = ClusterSeed(Matrix([[0,1],[-1,0],[1,0],[-1,1]])); S\n            A seed for a cluster algebra of rank 2 with 2 frozen variables\n            sage: T = ClusterSeed(Matrix([[0,1],[-1,0]])).principal_extension(); T\n            A seed for a cluster algebra of rank 2 with principal coefficients\n            sage: S.mutate(0)\n            sage: T.mutate(0)\n            sage: S.f_polynomials()\n            Traceback (most recent call last):\n            ...\n            ValueError: No principal coefficients initialized. Use principal_extension, or ignore_coefficients to ignore this.\n            sage: S.f_polynomials(ignore_coefficients=True)\n            [y0 + y1, 1]\n            sage: T.f_polynomials()\n            [y0 + 1, 1]\n        \"\"\"\n        if not (ignore_coefficients or self._is_principal):\n            raise ValueError(\"No principal coefficients initialized. Use principal_extension, or ignore_coefficients to ignore this.\")\n\n        if k not in range(self._n):\n            raise ValueError(\"The cluster seed does not have a cluster variable of index %s.\"%k)\n        eval_dict = dict( [ ( self.x(i), 1 ) for i in range(self._n) ] )\n        return self.cluster_variable(k).subs(eval_dict)\n\n    def f_polynomials(self,ignore_coefficients=False):\n        r\"\"\"\n        Returns all *F-polynomials* of ``self``. These are obtained from the\n        cluster variables by setting all `x_i`'s to `1`.\n\n        Requires principal coefficients, initialized by using principal_extension(),\n        or the user can set 'ignore_coefficients=True' to bypass this restriction.\n\n        Warning: this method assumes the sign-coherence conjecture and that the\n        input seed is sign-coherent (has an exchange matrix with columns of like signs).\n        Otherwise, computational errors might arise.\n\n        EXAMPLES::\n\n            sage: S = ClusterSeed(['A',3]).principal_extension()\n            sage: S.mutate([2,1,2])\n            sage: S.f_polynomials()\n            [1, y1*y2 + y2 + 1, y1 + 1]\n        \"\"\"\n        if not (ignore_coefficients or self._is_principal):\n            raise ValueError(\"No principal coefficients initialized. Use principal_extension, or ignore_coefficients to ignore this.\")\n\n        return [ self.f_polynomial(k,ignore_coefficients=ignore_coefficients) for k in range(self._n) ]\n\n    def g_vector(self,k,ignore_coefficients=False):\n        r\"\"\"\n        Returns the ``k``-th *g-vector* of ``self``. This is the degree vector\n        of the ``k``-th cluster variable after setting all `y_i`'s to `0`.\n\n        Requires principal coefficients, initialized by using principal_extension(),\n        or the user can set 'ignore_coefficients=True' to bypass this restriction.\n\n        Warning: this method assumes the sign-coherence conjecture and that the\n        input seed is sign-coherent (has an exchange matrix with columns of like signs).\n        Otherwise, computational errors might arise.\n\n        EXAMPLES::\n\n            sage: S = ClusterSeed(['A',3]).principal_extension()\n            sage: S.mutate([2,1,2])\n            sage: [ S.g_vector(k) for k in range(3) ]\n            [(1, 0, 0), (0, 0, -1), (0, -1, 0)]\n        \"\"\"\n        if not (ignore_coefficients or self._is_principal):\n            raise ValueError(\"No principal coefficients initialized. Use principal_extension, or ignore_coefficients to ignore this.\")\n        if k not in range(self._n):\n            raise ValueError(\"The cluster seed does not have a cluster variable of index %s.\"%k)\n        f = self.cluster_variable(k)\n        eval_dict = dict( [ ( self.y(i), 0 ) for i in range(self._m) ] )\n        f0 = f.subs(eval_dict)\n        d1 = f0.numerator().degrees()\n        d2 = f0.denominator().degrees()\n        return tuple( d1[i] - d2[i] for i in range(self._n) )\n\n    def g_matrix(self,ignore_coefficients=False):\n        r\"\"\"\n        Returns the matrix of all *g-vectors* of ``self``. This are the degree vectors\n        of the cluster variables after setting all `y_i`'s to `0`.\n\n        Requires principal coefficients, initialized by using principal_extension(),\n        or the user can set 'ignore_coefficients=True' to bypass this restriction.\n\n        Warning: this method assumes the sign-coherence conjecture and that the\n        input seed is sign-coherent (has an exchange matrix with columns of like signs).\n        Otherwise, computational errors might arise.\n\n        EXAMPLES::\n\n            sage: S = ClusterSeed(['A',3]).principal_extension()\n            sage: S.mutate([2,1,2])\n            sage: S.g_matrix()\n            [ 1  0  0]\n            [ 0  0 -1]\n            [ 0 -1  0]\n\n            sage: S = ClusterSeed(['A',3])\n            sage: S2 = S.principal_extension()\n            sage: S.mutate([0,1])\n            sage: S2.mutate([0,1])\n            sage: S.g_matrix()\n            Traceback (most recent call last):\n            ...\n            ValueError: No principal coefficients initialized. Use\n            principal_extension, or ignore_coefficients to ignore this.\n            sage: S.g_matrix(ignore_coefficients=True)\n            [-1  0  0]\n            [ 1  0  0]\n            [ 0  1  1]\n            sage: S2.g_matrix()\n            [-1 -1  0]\n            [ 1  0  0]\n            [ 0  0  1]\n        \"\"\"\n        from sage.matrix.all import matrix\n        if not (ignore_coefficients or self._is_principal):\n            raise ValueError(\"No principal coefficients initialized. Use principal_extension, or ignore_coefficients to ignore this.\")\n        return matrix( [ self.g_vector(k,ignore_coefficients=ignore_coefficients) for k in range(self._n) ] ).transpose()\n\n    def c_vector(self,k,ignore_coefficients=False):\n        r\"\"\"\n        Returns the ``k``-th *c-vector* of ``self``. It is obtained as the\n        ``k``-th column vector of the bottom part of the ``B``-matrix of ``self``.\n\n        Requires principal coefficients, initialized by using principal_extension(),\n        or the user can set 'ignore_coefficients=True' to bypass this restriction.\n\n        Warning: this method assumes the sign-coherence conjecture and that the\n        input seed is sign-coherent (has an exchange matrix with columns of like signs).\n        Otherwise, computational errors might arise.\n\n        EXAMPLES::\n\n            sage: S = ClusterSeed(['A',3]).principal_extension()\n            sage: S.mutate([2,1,2])\n            sage: [ S.c_vector(k) for k in range(3) ]\n            [(1, 0, 0), (0, 0, -1), (0, -1, 0)]\n\n            sage: S = ClusterSeed(Matrix([[0,1],[-1,0],[1,0],[-1,1]])); S\n            A seed for a cluster algebra of rank 2 with 2 frozen variables\n            sage: S.c_vector(0)\n            Traceback (most recent call last):\n            ...\n            ValueError: No principal coefficients initialized. Use principal_extension, or ignore_coefficients to ignore this.\n            sage: S.c_vector(0,ignore_coefficients=True)\n            (1, -1)\n        \"\"\"\n        if k not in range(self._n):\n            raise ValueError(\"The cluster seed does not have a c-vector of index %s.\"%k)\n        if not (ignore_coefficients or self._is_principal):\n            raise ValueError(\"No principal coefficients initialized. Use principal_extension, or ignore_coefficients to ignore this.\")\n        return tuple( self._M[i,k] for i in range(self._n,self._n+self._m) )\n\n    def c_matrix(self,ignore_coefficients=False):\n        r\"\"\"\n        Returns all *c-vectors* of ``self``.\n\n        Requires principal coefficients, initialized by using principal_extension(),\n        or the user can set 'ignore_coefficients=True' to bypass this restriction.\n\n        Warning: this method assumes the sign-coherence conjecture and that the\n        input seed is sign-coherent (has an exchange matrix with columns of like signs).\n        Otherwise, computational errors might arise.\n\n        EXAMPLES::\n\n            sage: S = ClusterSeed(['A',3]).principal_extension()\n            sage: S.mutate([2,1,2])\n            sage: S.c_matrix()\n            [ 1  0  0]\n            [ 0  0 -1]\n            [ 0 -1  0]\n        \"\"\"\n        if not (ignore_coefficients or self._is_principal):\n            raise ValueError(\"No principal coefficients initialized. Use principal_extension, or ignore_coefficients to ignore this.\")\n\n        return self._M.submatrix(self._n,0)\n\n    def coefficient(self,k):\n        r\"\"\"\n        Returns the *coefficient* of ``self`` at index ``k``.\n\n        EXAMPLES::\n\n            sage: S = ClusterSeed(['A',3]).principal_extension()\n            sage: S.mutate([2,1,2])\n            sage: [ S.coefficient(k) for k in range(3) ]\n            [y0, 1/y2, 1/y1]\n        \"\"\"\n        from sage.misc.all import prod\n        if k not in range(self._n):\n            raise ValueError(\"The cluster seed does not have a coefficient of index %s.\"%k)\n        if self._m == 0:\n            return self.x(0)**0\n        #### Note: this special case m = 0 no longer needed except if we want type(answer) to be a cluster variable rather than an integer.\n        else:\n            exp = self.c_vector(k,ignore_coefficients=True)\n            return prod( self.y(i)**exp[i] for i in xrange(self._m) )\n\n    def coefficients(self):\n        r\"\"\"\n        Returns all *coefficients* of ``self``.\n\n        EXAMPLES::\n\n            sage: S = ClusterSeed(['A',3]).principal_extension()\n            sage: S.mutate([2,1,2])\n            sage: S.coefficients()\n            [y0, 1/y2, 1/y1]\n        \"\"\"\n        return [ self.coefficient(k) for k in range(self._n) ]\n\n    def quiver(self):\n        r\"\"\"\n        Returns the *quiver* associated to ``self``.\n\n        EXAMPLES::\n\n            sage: S = ClusterSeed(['A',3])\n            sage: S.quiver()\n            Quiver on 3 vertices of type ['A', 3]\n        \"\"\"\n        from sage.combinat.cluster_algebra_quiver.quiver import ClusterQuiver\n        if self._quiver is None:\n            self._quiver = ClusterQuiver( self._M )\n        return self._quiver\n\n    def is_acyclic(self):\n        r\"\"\"\n        Returns True iff self is acyclic (i.e., if the underlying quiver is acyclic).\n\n        EXAMPLES::\n\n            sage: ClusterSeed(['A',4]).is_acyclic()\n            True\n\n            sage: ClusterSeed(['A',[2,1],1]).is_acyclic()\n            True\n\n            sage: ClusterSeed([[0,1],[1,2],[2,0]]).is_acyclic()\n            False\n        \"\"\"\n        return self.quiver()._digraph.is_directed_acyclic()\n\n    def is_bipartite(self,return_bipartition=False):\n        r\"\"\"\n        Returns True iff self is bipartite (i.e., if the underlying quiver is bipartite).\n\n        INPUT:\n\n        - return_bipartition -- (default:False) if True, the bipartition is returned in the case of ``self`` being bipartite.\n\n        EXAMPLES::\n\n            sage: ClusterSeed(['A',[3,3],1]).is_bipartite()\n            True\n\n            sage: ClusterSeed(['A',[4,3],1]).is_bipartite()\n            False\n        \"\"\"\n        return self.quiver().is_bipartite(return_bipartition=return_bipartition)\n\n    def mutate(self, sequence, inplace=True):\n        r\"\"\"\n        Mutates ``self`` at a vertex or a sequence of vertices.\n\n        INPUT:\n\n        - ``sequence`` -- a vertex of self or an iterator of vertices of self.\n        - ``inplace`` -- (default: True) if False, the result is returned, otherwise ``self`` is modified.\n\n        EXAMPLES::\n\n            sage: S = ClusterSeed(['A',4]); S.b_matrix()\n            [ 0  1  0  0]\n            [-1  0 -1  0]\n            [ 0  1  0  1]\n            [ 0  0 -1  0]\n\n            sage: S.mutate(0); S.b_matrix()\n            [ 0 -1  0  0]\n            [ 1  0 -1  0]\n            [ 0  1  0  1]\n            [ 0  0 -1  0]\n\n            sage: T = S.mutate(0, inplace=False); T\n            A seed for a cluster algebra of rank 4 of type ['A', 4]\n\n            sage: S.mutate(0)\n            sage: S == T\n            True\n\n            sage: S.mutate([0,1,0])\n            sage: S.b_matrix()\n            [ 0 -1  1  0]\n            [ 1  0  0  0]\n            [-1  0  0  1]\n            [ 0  0 -1  0]\n\n            sage: S = ClusterSeed(QuiverMutationType([['A',1],['A',3]]))\n            sage: S.b_matrix()\n            [ 0  0  0  0]\n            [ 0  0  1  0]\n            [ 0 -1  0 -1]\n            [ 0  0  1  0]\n\n            sage: T = S.mutate(0,inplace=False)\n            sage: S == T\n            False\n        \"\"\"\n        if inplace:\n            seed = self\n        else:\n            seed = ClusterSeed( self )\n\n        n, m = seed._n, seed._m\n        V = range(n)\n\n        if sequence in V:\n            seq = [sequence]\n        else:\n            seq = sequence\n        if isinstance(seq, tuple):\n            seq = list( seq )\n        if not isinstance(seq, list):\n            raise ValueError('The quiver can only be mutated at a vertex or at a sequence of vertices')\n        if not isinstance(inplace, bool):\n            raise ValueError('The second parameter must be boolean.  To mutate at a sequence of length 2, input it as a list.')\n        if any( v not in V for v in seq ):\n            v = filter( lambda v: v not in V, seq )[0]\n            raise ValueError('The quiver cannot be mutated at the vertex ' + str( v ))\n\n        for k in seq:\n            M = seed._M\n            cluster = seed._cluster\n            mon_p = seed._R(1)\n            mon_n = seed._R(1)\n\n            for j in range(n+m):\n                if M[j,k] > 0:\n                    mon_p = mon_p*cluster[j]**M[j,k]\n                elif M[j,k] < 0:\n                    mon_n = mon_n*cluster[j]**(-M[j,k])\n\n            cluster[k] = (mon_p+mon_n)*cluster[k]**(-1)\n            seed._M.mutate(k)\n            #seed._M = _matrix_mutate( seed._M, k )\n\n        seed._quiver = None\n        if not inplace:\n            return seed\n\n    def mutation_sequence(self, sequence, show_sequence=False, fig_size=1.2,return_output='seed'):\n        r\"\"\"\n        Returns the seeds obtained by mutating ``self`` at all vertices in ``sequence``.\n\n        INPUT:\n\n        - ``sequence`` -- an iterable of vertices of self.\n        - ``show_sequence`` -- (default: False) if True, a png containing the associated quivers is shown.\n        - ``fig_size`` -- (default: 1.2) factor by which the size of the plot is multiplied.\n        - ``return_output`` -- (default: 'seed') determines what output is to be returned::\n\n            * if 'seed', outputs all the cluster seeds obtained by the ``sequence`` of mutations.\n            * if 'matrix', outputs a list of exchange matrices.\n            * if 'var', outputs a list of new cluster variables obtained at each step.\n\n        EXAMPLES::\n\n            sage: S = ClusterSeed(['A',2])\n            sage: for T in S.mutation_sequence([0,1,0]):\n            ...     print T.b_matrix()\n            [ 0 -1]\n            [ 1  0]\n            [ 0  1]\n            [-1  0]\n            [ 0 -1]\n            [ 1  0]\n\n            sage: S=ClusterSeed(['A',2])\n            sage: S.mutation_sequence([0,1,0,1],return_output='var')\n            [(x1 + 1)/x0, (x0 + x1 + 1)/(x0*x1), (x0 + 1)/x1, x0]\n        \"\"\"\n        seed = ClusterSeed( self )\n\n        new_clust_var = []\n        seed_sequence = []\n\n        for v in sequence:\n            seed = seed.mutate(v,inplace=False)\n            new_clust_var.append( seed._cluster[v])\n            seed_sequence.append( seed )\n\n        if show_sequence:\n            self.quiver().mutation_sequence(sequence=sequence, show_sequence=True, fig_size=fig_size )\n\n        if return_output=='seed':\n            return seed_sequence\n        elif return_output=='matrix':\n            return [ seed._M for seed in seed_sequence ]\n        elif return_output=='var':\n            return new_clust_var\n        else:\n            raise ValueError('The parameter `return_output` can only be `seed`, `matrix`, or `var`.')\n\n    def exchangeable_part(self):\n        r\"\"\"\n        Returns the restriction to the principal part (i.e. the exchangeable variables) of ``self``.\n\n        EXAMPLES::\n\n            sage: S = ClusterSeed(['A',4])\n            sage: T = ClusterSeed( S.quiver().digraph().edges(), frozen=1 )\n            sage: T.quiver().digraph().edges()\n            [(0, 1, (1, -1)), (2, 1, (1, -1)), (2, 3, (1, -1))]\n\n            sage: T.exchangeable_part().quiver().digraph().edges()\n            [(0, 1, (1, -1)), (2, 1, (1, -1))]\n\n            sage: S2 = S.principal_extension()\n            sage: S3 = S2.principal_extension(ignore_coefficients=True)\n            sage: S2.exchangeable_part() == S3.exchangeable_part()\n            True\n        \"\"\"\n        from sage.combinat.cluster_algebra_quiver.mutation_class import _principal_part\n        eval_dict = dict( [ ( self.y(i), 1 ) for i in xrange(self._m) ] )\n        seed = ClusterSeed( _principal_part( self._M ) )\n        seed._cluster = [ self._cluster[k].subs(eval_dict) for k in xrange(self._n) ]\n        seed._mutation_type = self._mutation_type\n        return seed\n\n    def universal_extension(self):\n        r\"\"\"\n        Returns the universal extension of ``self``.\n\n        This is the initial seed of the associated cluster algebra\n        with universal coefficients, as defined in section 12 of\n        :arxiv:`math/0602259`.\n\n        This method works only if ``self`` is a bipartite, finite-type seed.\n\n        Due to some limitations in the current implementation of\n        ``CartanType``, we need to construct the set of almost positive\n        coroots by hand. As a consequence their ordering is not the\n        standard one (the rows of the bottom part of the exchange\n        matrix might be a shuffling of those you would expect).\n\n        EXAMPLES::\n\n            sage: S = ClusterSeed(['A',2])\n            sage: T = S.universal_extension()\n            sage: T.b_matrix()\n            [ 0  1]\n            [-1  0]\n            [-1  0]\n            [ 1  0]\n            [ 1 -1]\n            [ 0  1]\n            [ 0 -1]\n\n            sage: S = ClusterSeed(['A',3])\n            sage: T = S.universal_extension()\n            sage: T.b_matrix()\n            [ 0  1  0]\n            [-1  0 -1]\n            [ 0  1  0]\n            [-1  0  0]\n            [ 1  0  0]\n            [ 1 -1  0]\n            [ 1 -1  1]\n            [ 0  1  0]\n            [ 0 -1  0]\n            [ 0 -1  1]\n            [ 0  0 -1]\n            [ 0  0  1]\n\n            sage: S = ClusterSeed(['B',2])\n            sage: T = S.universal_extension()\n            sage: T.b_matrix()\n            [ 0  1]\n            [-2  0]\n            [-1  0]\n            [ 1  0]\n            [ 1 -1]\n            [ 2 -1]\n            [ 0  1]\n            [ 0 -1]\n\n        \"\"\"\n        if self._m != 0:\n            raise ValueError(\"To have universal coefficients we need \"\n                             \"to start from a coefficient-free seed\")\n        if not self.is_bipartite() or not self.is_finite():\n            raise ValueError(\"Universal coefficients are defined only \"\n                             \"for finite type cluster algebras at a \"\n                             \"bipartite initial cluster\")\n\n        from sage.matrix.all import matrix\n        from sage.combinat.root_system.cartan_matrix import CartanMatrix\n\n        A = 2 - self.b_matrix().apply_map(abs).transpose()\n\n        rs = CartanMatrix(A).root_space()\n        almost_positive_coroots = rs.almost_positive_roots()\n\n        sign = [-1 if all(x <= 0 for x in self.b_matrix()[i]) else 1\n                for i in range(self._n)]\n        C = matrix([[sign[j] * alpha[j + 1] for j in range(self._n)]\n                    for alpha in almost_positive_coroots])\n\n        M = self._M.stack(C)\n        seed = ClusterSeed(M, is_principal=False)\n        seed._mutation_type = self._mutation_type\n        return seed\n\n    def principal_extension(self,ignore_coefficients=False):\n        r\"\"\"\n        Returns the principal extension of self, yielding a 2n-by-n matrix.  Raises an error if the input seed has a non-square exchange matrix,\n        unless 'ignore_coefficients=True' is set.  In this case, the method instead adds n frozen variables to any previously frozen variables.\n        I.e., the seed obtained by adding a frozen variable to every exchangeable variable of ``self``.\n\n        EXAMPLES::\n\n            sage: S = ClusterSeed([[0,1],[1,2],[2,3],[2,4]]); S\n            A seed for a cluster algebra of rank 5\n\n            sage: T = S.principal_extension(); T\n            A seed for a cluster algebra of rank 5 with principal coefficients\n\n            sage: T.b_matrix()\n            [ 0  1  0  0  0]\n            [-1  0  1  0  0]\n            [ 0 -1  0  1  1]\n            [ 0  0 -1  0  0]\n            [ 0  0 -1  0  0]\n            [ 1  0  0  0  0]\n            [ 0  1  0  0  0]\n            [ 0  0  1  0  0]\n            [ 0  0  0  1  0]\n            [ 0  0  0  0  1]\n\n            sage: T2 = T.principal_extension()\n            Traceback (most recent call last):\n            ...\n            ValueError: The b-matrix is not square. Use ignore_coefficients to ignore this.\n\n            sage: T2 = T.principal_extension(ignore_coefficients=True); T2.b_matrix()\n            [ 0  1  0  0  0]\n            [-1  0  1  0  0]\n            [ 0 -1  0  1  1]\n            [ 0  0 -1  0  0]\n            [ 0  0 -1  0  0]\n            [ 1  0  0  0  0]\n            [ 0  1  0  0  0]\n            [ 0  0  1  0  0]\n            [ 0  0  0  1  0]\n            [ 0  0  0  0  1]\n            [ 1  0  0  0  0]\n            [ 0  1  0  0  0]\n            [ 0  0  1  0  0]\n            [ 0  0  0  1  0]\n            [ 0  0  0  0  1]\n            \"\"\"\n        from sage.matrix.all import identity_matrix\n        if not ignore_coefficients and self._m != 0:\n            raise ValueError(\"The b-matrix is not square. Use ignore_coefficients to ignore this.\")\n        M = self._M.stack(identity_matrix(self._n))\n        is_principal = (self._m == 0)\n        seed = ClusterSeed( M, is_principal=is_principal )\n        seed._mutation_type = self._mutation_type\n        return seed\n\n    def reorient( self, data ):\n        r\"\"\"\n        Reorients ``self`` with respect to the given total order,\n        or with respect to an iterator of ordered pairs.\n\n        WARNING:\n\n        - This operation might change the mutation type of ``self``.\n        - Ignores ordered pairs `(i,j)` for which neither `(i,j)` nor `(j,i)` is an edge of ``self``.\n\n        INPUT:\n\n        - ``data`` -- an iterator defining a total order on ``self.vertices()``, or an iterator of ordered pairs in ``self`` defining the new orientation of these edges.\n\n        EXAMPLES::\n\n            sage: S = ClusterSeed(['A',[2,3],1])\n            sage: S.mutation_type()\n            ['A', [2, 3], 1]\n\n            sage: S.reorient([(0,1),(2,3)])\n            sage: S.mutation_type()\n            ['D', 5]\n\n            sage: S.reorient([(1,0),(2,3)])\n            sage: S.mutation_type()\n            ['A', [1, 4], 1]\n\n            sage: S.reorient([0,1,2,3,4])\n            sage: S.mutation_type()\n            ['A', [1, 4], 1]\n        \"\"\"\n        if not self._quiver:\n            self.quiver()\n        self._quiver.reorient( data )\n        self._M = self._quiver._M\n        self.reset_cluster()\n        self._mutation_type = None\n\n    def set_cluster( self, cluster ):\n        r\"\"\"\n        Sets the cluster for ``self`` to ``cluster``.\n\n        INPUT:\n\n        - ``cluster`` -- an iterable defining a cluster for ``self``.\n\n        EXAMPLES::\n\n            sage: S = ClusterSeed(['A',3])\n            sage: cluster = S.cluster()\n            sage: S.mutate([1,2,1])\n            sage: S.cluster()\n            [x0, (x1 + 1)/x2, (x0*x2 + x1 + 1)/(x1*x2)]\n\n            sage: S.set_cluster(cluster)\n            sage: S.cluster()\n            [x0, x1, x2]\n        \"\"\"\n        if not len(cluster) == self._n+self._m:\n            raise ValueError('The number of given cluster variables is wrong')\n        if any(c not in self._R for c in cluster):\n            raise ValueError('The cluster variables are not all contained in %s'%self._R)\n        self._cluster = [ self._R(x) for x in cluster ]\n        self._is_principal = None\n\n    def reset_cluster( self ):\n        r\"\"\"\n        Resets the cluster of ``self`` to the initial cluster.\n\n        EXAMPLES::\n\n            sage: S = ClusterSeed(['A',3])\n            sage: S.mutate([1,2,1])\n            sage: S.cluster()\n            [x0, (x1 + 1)/x2, (x0*x2 + x1 + 1)/(x1*x2)]\n\n            sage: S.reset_cluster()\n            sage: S.cluster()\n            [x0, x1, x2]\n\n            sage: T = S.principal_extension()\n            sage: T.cluster()\n            [x0, x1, x2]\n            sage: T.mutate([1,2,1])\n            sage: T.cluster()\n            [x0, (x1*y2 + x0)/x2, (x1*y1*y2 + x0*y1 + x2)/(x1*x2)]\n\n            sage: T.reset_cluster()\n            sage: T.cluster()\n            [x0, x1, x2]\n        \"\"\"\n        self.set_cluster(self._R.gens())\n\n    def reset_coefficients( self ):\n        r\"\"\"\n        Resets the coefficients of ``self`` to the frozen variables but keeps the current cluster.\n        Raises an error if the number of frozen variables is different than the number of exchangeable variables.\n\n        EXAMPLES::\n\n            sage: S = ClusterSeed(['A',3]).principal_extension()\n            sage: S.b_matrix()\n            [ 0  1  0]\n            [-1  0 -1]\n            [ 0  1  0]\n            [ 1  0  0]\n            [ 0  1  0]\n            [ 0  0  1]\n            sage: S.mutate([1,2,1])\n            sage: S.b_matrix()\n            [ 0  1 -1]\n            [-1  0  1]\n            [ 1 -1  0]\n            [ 1  0  0]\n            [ 0  1 -1]\n            [ 0  0 -1]\n            sage: S.reset_coefficients()\n            sage: S.b_matrix()\n            [ 0  1 -1]\n            [-1  0  1]\n            [ 1 -1  0]\n            [ 1  0  0]\n            [ 0  1  0]\n            [ 0  0  1]\n        \"\"\"\n        n,m = self._n, self._m\n        if not n == m:\n            raise ValueError(\"The numbers of cluster variables and of frozen variables do not coincide.\")\n        for i in xrange(m):\n            for j in xrange(n):\n                if i == j:\n                    self._M[i+n,j] = 1\n                else:\n                    self._M[i+n,j] = 0\n        self._quiver = None\n        self._is_principal = None\n\n    def mutation_class_iter( self, depth=infinity, show_depth=False, return_paths=False, up_to_equivalence=True, only_sink_source=False ):\n        r\"\"\"\n        Returns an iterator for the mutation class of ``self`` with respect to certain constrains.\n\n        INPUT:\n\n        - ``depth`` -- (default: infinity) integer or infinity, only seeds with distance at most ``depth`` from ``self`` are returned.\n        - ``show_depth`` -- (default: False) if True, the current depth of the mutation is shown while computing.\n        - ``return_paths`` -- (default: False) if True, a shortest path of mutations from ``self`` to the given quiver is returned as well.\n        - ``up_to_equivalence`` -- (default: True) if True, only one seed up to simultaneous permutation of rows and columns of the exchange matrix is recorded.\n        - ``sink_source`` -- (default: False) if True, only mutations at sinks and sources are applied.\n\n        EXAMPLES:\n\n        A standard finite type example::\n\n            sage: S = ClusterSeed(['A',3])\n            sage: it = S.mutation_class_iter()\n            sage: for T in it: print T\n            A seed for a cluster algebra of rank 3 of type ['A', 3]\n            A seed for a cluster algebra of rank 3 of type ['A', 3]\n            A seed for a cluster algebra of rank 3 of type ['A', 3]\n            A seed for a cluster algebra of rank 3 of type ['A', 3]\n            A seed for a cluster algebra of rank 3 of type ['A', 3]\n            A seed for a cluster algebra of rank 3 of type ['A', 3]\n            A seed for a cluster algebra of rank 3 of type ['A', 3]\n            A seed for a cluster algebra of rank 3 of type ['A', 3]\n            A seed for a cluster algebra of rank 3 of type ['A', 3]\n            A seed for a cluster algebra of rank 3 of type ['A', 3]\n            A seed for a cluster algebra of rank 3 of type ['A', 3]\n            A seed for a cluster algebra of rank 3 of type ['A', 3]\n            A seed for a cluster algebra of rank 3 of type ['A', 3]\n            A seed for a cluster algebra of rank 3 of type ['A', 3]\n\n        A finite type example with given depth::\n\n            sage: it = S.mutation_class_iter(depth=1)\n            sage: for T in it: print T\n            A seed for a cluster algebra of rank 3 of type ['A', 3]\n            A seed for a cluster algebra of rank 3 of type ['A', 3]\n            A seed for a cluster algebra of rank 3 of type ['A', 3]\n            A seed for a cluster algebra of rank 3 of type ['A', 3]\n\n        A finite type example where the depth is shown while computing::\n\n            sage: it = S.mutation_class_iter(show_depth=True)\n            sage: for T in it: pass\n            Depth: 0     found: 1          Time: ... s\n            Depth: 1     found: 4          Time: ... s\n            Depth: 2     found: 9          Time: ... s\n            Depth: 3     found: 13         Time: ... s\n            Depth: 4     found: 14         Time: ... s\n\n        A finite type example with shortest paths returned::\n\n            sage: it = S.mutation_class_iter(return_paths=True)\n            sage: for T in it: print T\n            (A seed for a cluster algebra of rank 3 of type ['A', 3], [])\n            (A seed for a cluster algebra of rank 3 of type ['A', 3], [2])\n            (A seed for a cluster algebra of rank 3 of type ['A', 3], [1])\n            (A seed for a cluster algebra of rank 3 of type ['A', 3], [0])\n            (A seed for a cluster algebra of rank 3 of type ['A', 3], [2, 1])\n            (A seed for a cluster algebra of rank 3 of type ['A', 3], [0, 2])\n            (A seed for a cluster algebra of rank 3 of type ['A', 3], [0, 1])\n            (A seed for a cluster algebra of rank 3 of type ['A', 3], [1, 2])\n            (A seed for a cluster algebra of rank 3 of type ['A', 3], [1, 0])\n            (A seed for a cluster algebra of rank 3 of type ['A', 3], [0, 2, 1])\n            (A seed for a cluster algebra of rank 3 of type ['A', 3], [0, 1, 2])\n            (A seed for a cluster algebra of rank 3 of type ['A', 3], [2, 1, 0])\n            (A seed for a cluster algebra of rank 3 of type ['A', 3], [1, 0, 2])\n            (A seed for a cluster algebra of rank 3 of type ['A', 3], [0, 1, 2, 0])\n\n        Finite type examples not considered up to equivalence::\n\n            sage: it = S.mutation_class_iter(up_to_equivalence=False)\n            sage: len( [ T for T in it ] )\n            84\n\n            sage: it = ClusterSeed(['A',2]).mutation_class_iter(return_paths=True,up_to_equivalence=False)\n            sage: for T in it: print T\n            (A seed for a cluster algebra of rank 2 of type ['A', 2], [])\n            (A seed for a cluster algebra of rank 2 of type ['A', 2], [1])\n            (A seed for a cluster algebra of rank 2 of type ['A', 2], [0])\n            (A seed for a cluster algebra of rank 2 of type ['A', 2], [0, 1])\n            (A seed for a cluster algebra of rank 2 of type ['A', 2], [1, 0])\n            (A seed for a cluster algebra of rank 2 of type ['A', 2], [1, 0, 1])\n            (A seed for a cluster algebra of rank 2 of type ['A', 2], [0, 1, 0])\n            (A seed for a cluster algebra of rank 2 of type ['A', 2], [1, 0, 1, 0])\n            (A seed for a cluster algebra of rank 2 of type ['A', 2], [0, 1, 0, 1])\n            (A seed for a cluster algebra of rank 2 of type ['A', 2], [1, 0, 1, 0, 1])\n\n        Check that :trac:`14638` is fixed::\n\n            sage: S = ClusterSeed(['E',6])\n            sage: MC = S.mutation_class(depth=7); len(MC)\n            534\n\n        Infinite type examples::\n\n            sage: S = ClusterSeed(['A',[1,1],1])\n            sage: it = S.mutation_class_iter()\n            sage: next(it)\n            A seed for a cluster algebra of rank 2 of type ['A', [1, 1], 1]\n            sage: next(it)\n            A seed for a cluster algebra of rank 2 of type ['A', [1, 1], 1]\n            sage: next(it)\n            A seed for a cluster algebra of rank 2 of type ['A', [1, 1], 1]\n            sage: next(it)\n            A seed for a cluster algebra of rank 2 of type ['A', [1, 1], 1]\n\n            sage: it = S.mutation_class_iter(depth=3, return_paths=True)\n            sage: for T in it: print T\n            (A seed for a cluster algebra of rank 2 of type ['A', [1, 1], 1], [])\n            (A seed for a cluster algebra of rank 2 of type ['A', [1, 1], 1], [1])\n            (A seed for a cluster algebra of rank 2 of type ['A', [1, 1], 1], [0])\n            (A seed for a cluster algebra of rank 2 of type ['A', [1, 1], 1], [1, 0])\n            (A seed for a cluster algebra of rank 2 of type ['A', [1, 1], 1], [0, 1])\n            (A seed for a cluster algebra of rank 2 of type ['A', [1, 1], 1], [1, 0, 1])\n            (A seed for a cluster algebra of rank 2 of type ['A', [1, 1], 1], [0, 1, 0])\n        \"\"\"\n        depth_counter = 0\n        n = self._n\n        timer = time.time()\n        if return_paths:\n            yield (self,[])\n        else:\n            yield self\n        if up_to_equivalence:\n            cl = Set( self._cluster )\n        else:\n            cl = tuple( self._cluster )\n        clusters = {}\n        clusters[ cl ] = [ self, range(n), [] ]\n        gets_bigger = True\n        if show_depth:\n            timer2 = time.time()\n            dc = str(depth_counter)\n            dc += ' ' * (5-len(dc))\n            nr = str(len(clusters))\n            nr += ' ' * (10-len(nr))\n            print \"Depth: %s found: %s Time: %.2f s\"%(dc,nr,timer2-timer)\n        while gets_bigger and depth_counter < depth:\n            gets_bigger = False\n            keys = clusters.keys()\n            for key in keys:\n                sd = clusters[key]\n                while sd[1]:\n                    i = sd[1].pop()\n                    if not only_sink_source or all( entry >= 0 for entry in sd[0]._M.row( i ) ) or all( entry <= 0 for entry in sd[0]._M.row( i ) ):\n                        sd2  = sd[0].mutate( i, inplace=False )\n                        if up_to_equivalence:\n                            cl2 = Set(sd2._cluster)\n                        else:\n                            cl2 = tuple(sd2._cluster)\n                        if cl2 in clusters:\n                            if not up_to_equivalence and i in clusters[cl2][1]:\n                                clusters[cl2][1].remove(i)\n                        else:\n                            gets_bigger = True\n                            if only_sink_source:\n                                orbits = range(n)\n                            else:\n                                orbits = [ index for index in xrange(n) if index > i or sd2._M[index,i] != 0 ]\n\n                            clusters[ cl2 ] = [ sd2, orbits, clusters[key][2]+[i] ]\n                            if return_paths:\n                                yield (sd2,clusters[cl2][2])\n                            else:\n                                yield sd2\n            depth_counter += 1\n            if show_depth and gets_bigger:\n                timer2 = time.time()\n                dc = str(depth_counter)\n                dc += ' ' * (5-len(dc))\n                nr = str(len(clusters))\n                nr += ' ' * (10-len(nr))\n                print \"Depth: %s found: %s Time: %.2f s\"%(dc,nr,timer2-timer)\n\n    def mutation_class( self, depth=infinity, show_depth=False, return_paths=False, up_to_equivalence=True, only_sink_source=False ):\n        r\"\"\"\n        Returns the mutation class of ``self`` with respect to certain constraints.\n\n        INPUT:\n\n        - ``depth`` -- (default: infinity) integer, only seeds with distance at most depth from self are returned.\n        - ``show_depth`` -- (default: False) if True, the actual depth of the mutation is shown.\n        - ``return_paths`` -- (default: False) if True, a shortest path of mutation sequences from self to the given quiver is returned as well.\n        - ``up_to_equivalence`` -- (default: True) if True, only seeds up to equivalence are considered.\n        - ``sink_source`` -- (default: False) if True, only mutations at sinks and sources are applied.\n\n        EXAMPLES:\n\n        - for examples see :meth:`mutation_class_iter`\n\n        TESTS::\n\n            sage: A = ClusterSeed(['A',3]).mutation_class()\n        \"\"\"\n        if depth is infinity and not self.is_finite():\n            raise ValueError('The mutation class can - for infinite types - only be computed up to a given depth')\n        return list( S for S in self.mutation_class_iter( depth=depth, show_depth=show_depth, return_paths=return_paths, up_to_equivalence=up_to_equivalence, only_sink_source=only_sink_source ) )\n\n    def cluster_class_iter(self, depth=infinity, show_depth=False, up_to_equivalence=True):\n        r\"\"\"\n        Returns an iterator through all clusters in the mutation class of ``self``.\n\n        INPUT:\n\n        - ``depth`` -- (default: infinity) integer or infinity, only seeds with distance at most depth from self are returned\n        - ``show_depth`` -- (default False) - if True, ignored if depth is set; returns the depth of the mutation class, i.e., the maximal distance from self of an element in the mutation class\n        - ``up_to_equivalence`` -- (default: True) if True, only clusters up to equivalence are considered.\n\n        EXAMPLES:\n\n        A standard finite type example::\n\n            sage: S = ClusterSeed(['A',3])\n            sage: it = S.cluster_class_iter()\n            sage: for T in it: print T\n            [x0, x1, x2]\n            [x0, x1, (x1 + 1)/x2]\n            [x0, (x0*x2 + 1)/x1, x2]\n            [(x1 + 1)/x0, x1, x2]\n            [x0, (x0*x2 + x1 + 1)/(x1*x2), (x1 + 1)/x2]\n            [(x1 + 1)/x0, x1, (x1 + 1)/x2]\n            [(x1 + 1)/x0, (x0*x2 + x1 + 1)/(x0*x1), x2]\n            [x0, (x0*x2 + 1)/x1, (x0*x2 + x1 + 1)/(x1*x2)]\n            [(x0*x2 + x1 + 1)/(x0*x1), (x0*x2 + 1)/x1, x2]\n            [(x1 + 1)/x0, (x1^2 + x0*x2 + 2*x1 + 1)/(x0*x1*x2), (x1 + 1)/x2]\n            [(x1 + 1)/x0, (x0*x2 + x1 + 1)/(x0*x1), (x1^2 + x0*x2 + 2*x1 + 1)/(x0*x1*x2)]\n            [(x1^2 + x0*x2 + 2*x1 + 1)/(x0*x1*x2), (x0*x2 + x1 + 1)/(x1*x2), (x1 + 1)/x2]\n            [(x0*x2 + x1 + 1)/(x0*x1), (x0*x2 + 1)/x1, (x0*x2 + x1 + 1)/(x1*x2)]\n            [(x0*x2 + x1 + 1)/(x1*x2), (x0*x2 + x1 + 1)/(x0*x1), (x1^2 + x0*x2 + 2*x1 + 1)/(x0*x1*x2)]\n\n        A finite type example with given depth::\n\n            sage: it = S.cluster_class_iter(depth=1)\n            sage: for T in it: print T\n            [x0, x1, x2]\n            [x0, x1, (x1 + 1)/x2]\n            [x0, (x0*x2 + 1)/x1, x2]\n            [(x1 + 1)/x0, x1, x2]\n\n        A finite type example where the depth is returned while computing::\n\n            sage: it = S.cluster_class_iter(show_depth=True)\n            sage: for T in it: print T\n            [x0, x1, x2]\n            Depth: 0     found: 1          Time: ... s\n            [x0, x1, (x1 + 1)/x2]\n            [x0, (x0*x2 + 1)/x1, x2]\n            [(x1 + 1)/x0, x1, x2]\n            Depth: 1     found: 4          Time: ... s\n            [x0, (x0*x2 + x1 + 1)/(x1*x2), (x1 + 1)/x2]\n            [(x1 + 1)/x0, x1, (x1 + 1)/x2]\n            [(x1 + 1)/x0, (x0*x2 + x1 + 1)/(x0*x1), x2]\n            [x0, (x0*x2 + 1)/x1, (x0*x2 + x1 + 1)/(x1*x2)]\n            [(x0*x2 + x1 + 1)/(x0*x1), (x0*x2 + 1)/x1, x2]\n            Depth: 2     found: 9          Time: ... s\n            [(x1 + 1)/x0, (x1^2 + x0*x2 + 2*x1 + 1)/(x0*x1*x2), (x1 + 1)/x2]\n            [(x1 + 1)/x0, (x0*x2 + x1 + 1)/(x0*x1), (x1^2 + x0*x2 + 2*x1 + 1)/(x0*x1*x2)]\n            [(x1^2 + x0*x2 + 2*x1 + 1)/(x0*x1*x2), (x0*x2 + x1 + 1)/(x1*x2), (x1 + 1)/x2]\n            [(x0*x2 + x1 + 1)/(x0*x1), (x0*x2 + 1)/x1, (x0*x2 + x1 + 1)/(x1*x2)]\n            Depth: 3     found: 13         Time: ... s\n            [(x0*x2 + x1 + 1)/(x1*x2), (x0*x2 + x1 + 1)/(x0*x1), (x1^2 + x0*x2 + 2*x1 + 1)/(x0*x1*x2)]\n            Depth: 4     found: 14         Time: ... s\n\n        Finite type examples not considered up to equivalence::\n\n            sage: it = S.cluster_class_iter(up_to_equivalence=False)\n            sage: len( [ T for T in it ] )\n            84\n\n            sage: it = ClusterSeed(['A',2]).cluster_class_iter(up_to_equivalence=False)\n            sage: for T in it: print T\n            [x0, x1]\n            [x0, (x0 + 1)/x1]\n            [(x1 + 1)/x0, x1]\n            [(x1 + 1)/x0, (x0 + x1 + 1)/(x0*x1)]\n            [(x0 + x1 + 1)/(x0*x1), (x0 + 1)/x1]\n            [(x0 + x1 + 1)/(x0*x1), (x1 + 1)/x0]\n            [(x0 + 1)/x1, (x0 + x1 + 1)/(x0*x1)]\n            [x1, (x1 + 1)/x0]\n            [(x0 + 1)/x1, x0]\n            [x1, x0]\n\n        Infinite type examples::\n\n            sage: S = ClusterSeed(['A',[1,1],1])\n            sage: it = S.cluster_class_iter()\n            sage: next(it)\n            [x0, x1]\n            sage: next(it)\n            [x0, (x0^2 + 1)/x1]\n            sage: next(it)\n            [(x1^2 + 1)/x0, x1]\n            sage: next(it)\n            [(x0^4 + 2*x0^2 + x1^2 + 1)/(x0*x1^2), (x0^2 + 1)/x1]\n            sage: next(it)\n            [(x1^2 + 1)/x0, (x1^4 + x0^2 + 2*x1^2 + 1)/(x0^2*x1)]\n\n            sage: it = S.cluster_class_iter(depth=3)\n            sage: for T in it: print T\n            [x0, x1]\n            [x0, (x0^2 + 1)/x1]\n            [(x1^2 + 1)/x0, x1]\n            [(x0^4 + 2*x0^2 + x1^2 + 1)/(x0*x1^2), (x0^2 + 1)/x1]\n            [(x1^2 + 1)/x0, (x1^4 + x0^2 + 2*x1^2 + 1)/(x0^2*x1)]\n            [(x0^4 + 2*x0^2 + x1^2 + 1)/(x0*x1^2), (x0^6 + 3*x0^4 + 2*x0^2*x1^2 + x1^4 + 3*x0^2 + 2*x1^2 + 1)/(x0^2*x1^3)]\n            [(x1^6 + x0^4 + 2*x0^2*x1^2 + 3*x1^4 + 2*x0^2 + 3*x1^2 + 1)/(x0^3*x1^2), (x1^4 + x0^2 + 2*x1^2 + 1)/(x0^2*x1)]\n        \"\"\"\n        mc_iter = self.mutation_class_iter( depth=depth, show_depth=show_depth, up_to_equivalence=up_to_equivalence )\n        for c in mc_iter:\n            yield c.cluster()\n\n    def cluster_class(self, depth=infinity, show_depth=False, up_to_equivalence=True):\n        r\"\"\"\n        Returns the cluster class of ``self`` with respect to certain constraints.\n\n        INPUT:\n\n        - ``depth`` -- (default: infinity) integer, only seeds with distance at most depth from self are returned\n        - ``return_depth`` -- (default False) - if True, ignored if depth is set; returns the depth of the mutation class, i.e., the maximal distance from self of an element in the mutation class\n        - ``up_to_equivalence`` -- (default: True) if True, only clusters up to equivalence are considered.\n\n        EXAMPLES:\n\n        - for examples see :meth:`cluster_class_iter`\n\n        TESTS::\n\n            sage: A = ClusterSeed(['A',3]).cluster_class()\n        \"\"\"\n        if depth is infinity and not self.is_finite():\n            raise ValueError('The variable class can - for infinite types - only be computed up to a given depth')\n\n        return [ c for c in self.cluster_class_iter(depth=depth, show_depth=show_depth, up_to_equivalence=up_to_equivalence) ]\n\n    def b_matrix_class_iter(self, depth=infinity, up_to_equivalence=True):\n        r\"\"\"\n        Returns an iterator through all `B`-matrices in the mutation class of ``self``.\n\n        INPUT:\n\n        - ``depth`` -- (default:infinity) integer or infinity, only seeds with distance at most depth from self are returned\n        - ``up_to_equivalence`` -- (default: True) if True, only 'B'-matrices up to equivalence are considered.\n\n        EXAMPLES:\n\n        A standard finite type example::\n\n            sage: S = ClusterSeed(['A',4])\n            sage: it = S.b_matrix_class_iter()\n            sage: for T in it: print T\n            [ 0  0  0  1]\n            [ 0  0  1  1]\n            [ 0 -1  0  0]\n            [-1 -1  0  0]\n            [ 0  0  0  1]\n            [ 0  0  1  0]\n            [ 0 -1  0  1]\n            [-1  0 -1  0]\n            [ 0  0  1  1]\n            [ 0  0  0 -1]\n            [-1  0  0  0]\n            [-1  1  0  0]\n            [ 0  0  0  1]\n            [ 0  0 -1  1]\n            [ 0  1  0 -1]\n            [-1 -1  1  0]\n            [ 0  0  0  1]\n            [ 0  0 -1  0]\n            [ 0  1  0 -1]\n            [-1  0  1  0]\n            [ 0  0  0 -1]\n            [ 0  0 -1  1]\n            [ 0  1  0 -1]\n            [ 1 -1  1  0]\n\n        A finite type example with given depth::\n\n            sage: it = S.b_matrix_class_iter(depth=1)\n            sage: for T in it: print T\n            [ 0  0  0  1]\n            [ 0  0  1  1]\n            [ 0 -1  0  0]\n            [-1 -1  0  0]\n            [ 0  0  0  1]\n            [ 0  0  1  0]\n            [ 0 -1  0  1]\n            [-1  0 -1  0]\n            [ 0  0  1  1]\n            [ 0  0  0 -1]\n            [-1  0  0  0]\n            [-1  1  0  0]\n\n        Finite type example not considered up to equivalence::\n\n            sage: S = ClusterSeed(['A',3])\n            sage: it = S.b_matrix_class_iter(up_to_equivalence=False)\n            sage: for T in it: print T\n            [ 0  1  0]\n            [-1  0 -1]\n            [ 0  1  0]\n            [ 0  1  0]\n            [-1  0  1]\n            [ 0 -1  0]\n            [ 0 -1  0]\n            [ 1  0  1]\n            [ 0 -1  0]\n            [ 0 -1  0]\n            [ 1  0 -1]\n            [ 0  1  0]\n            [ 0 -1  1]\n            [ 1  0 -1]\n            [-1  1  0]\n            [ 0  1 -1]\n            [-1  0  1]\n            [ 1 -1  0]\n            [ 0  0  1]\n            [ 0  0 -1]\n            [-1  1  0]\n            [ 0 -1  1]\n            [ 1  0  0]\n            [-1  0  0]\n            [ 0  0 -1]\n            [ 0  0  1]\n            [ 1 -1  0]\n            [ 0  1 -1]\n            [-1  0  0]\n            [ 1  0  0]\n            [ 0  1  1]\n            [-1  0  0]\n            [-1  0  0]\n            [ 0 -1 -1]\n            [ 1  0  0]\n            [ 1  0  0]\n            [ 0  0 -1]\n            [ 0  0 -1]\n            [ 1  1  0]\n            [ 0  0  1]\n            [ 0  0  1]\n            [-1 -1  0]\n\n        Infinite (but finite mutation) type example::\n\n            sage: S = ClusterSeed(['A',[1,2],1])\n            sage: it = S.b_matrix_class_iter()\n            sage: for T in it: print T\n            [ 0  1  1]\n            [-1  0  1]\n            [-1 -1  0]\n            [ 0 -2  1]\n            [ 2  0 -1]\n            [-1  1  0]\n\n        Infinite mutation type example::\n\n            sage: S = ClusterSeed(['E',10])\n            sage: it = S.b_matrix_class_iter(depth=3)\n            sage: len ( [T for T in it] )\n            266\n        \"\"\"\n        Q = self.quiver()\n        for M in Q.mutation_class_iter( depth=depth, up_to_equivalence=up_to_equivalence, data_type='matrix' ):\n            yield M\n\n    def b_matrix_class(self, depth=infinity, up_to_equivalence=True):\n        r\"\"\"\n        Returns all `B`-matrices in the mutation class of ``self``.\n\n        INPUT:\n\n        - ``depth`` -- (default:infinity) integer or infinity, only seeds with distance at most depth from self are returned\n        - ``up_to_equivalence`` -- (default: True) if True, only 'B'-matrices up to equivalence are considered.\n\n        EXAMPLES:\n\n        - for examples see :meth:`b_matrix_class_iter`\n\n        TESTS::\n\n            sage: A = ClusterSeed(['A',3]).b_matrix_class()\n            sage: A = ClusterSeed(['A',[2,1],1]).b_matrix_class()\n        \"\"\"\n        if depth is infinity and not self.is_mutation_finite():\n            raise ValueError('The B-matrix class can - for infinite mutation types - only be computed up to a given depth')\n\n        return [ M for M in self.b_matrix_class_iter( depth=depth, up_to_equivalence=up_to_equivalence ) ]\n\n    def variable_class_iter(self, depth=infinity, ignore_bipartite_belt=False):\n        r\"\"\"\n        Returns an iterator for all cluster variables in the mutation class of ``self``.\n\n        INPUT:\n\n            - ``depth`` -- (default:infinity) integer, only seeds with distance at most depth from self are returned\n            - ``ignore_bipartite_belt`` -- (default:False) if True, the algorithms does not use the bipartite belt\n\n        EXAMPLES:\n\n        A standard finite type example::\n\n            sage: S = ClusterSeed(['A',3])\n            sage: it = S.variable_class_iter()\n            sage: for T in it: print T\n            x0\n            x1\n            x2\n            (x1 + 1)/x0\n            (x1^2 + x0*x2 + 2*x1 + 1)/(x0*x1*x2)\n            (x1 + 1)/x2\n            (x0*x2 + x1 + 1)/(x0*x1)\n            (x0*x2 + 1)/x1\n            (x0*x2 + x1 + 1)/(x1*x2)\n\n        Finite type examples with given depth::\n\n            sage: it = S.variable_class_iter(depth=1)\n            sage: for T in it: print T\n            Found a bipartite seed - restarting the depth counter at zero and constructing the variable class using its bipartite belt.\n            x0\n            x1\n            x2\n            (x1 + 1)/x0\n            (x1^2 + x0*x2 + 2*x1 + 1)/(x0*x1*x2)\n            (x1 + 1)/x2\n            (x0*x2 + x1 + 1)/(x0*x1)\n            (x0*x2 + 1)/x1\n            (x0*x2 + x1 + 1)/(x1*x2)\n\n        Note that the notion of *depth* depends on whether a bipartite seed is found or not, or if it is manually ignored::\n\n            sage: it = S.variable_class_iter(depth=1,ignore_bipartite_belt=True)\n            sage: for T in it: print T\n            x0\n            x1\n            x2\n            (x1 + 1)/x2\n            (x0*x2 + 1)/x1\n            (x1 + 1)/x0\n\n            sage: S.mutate([0,1])\n            sage: it2 = S.variable_class_iter(depth=1)\n            sage: for T in it2: print T\n            (x1 + 1)/x0\n            (x0*x2 + x1 + 1)/(x0*x1)\n            x2\n            (x1^2 + x0*x2 + 2*x1 + 1)/(x0*x1*x2)\n            x1\n            (x0*x2 + 1)/x1\n\n        Infinite type examples::\n\n            sage: S = ClusterSeed(['A',[1,1],1])\n            sage: it = S.variable_class_iter(depth=2)\n            sage: for T in it: print T\n            Found a bipartite seed - restarting the depth counter at zero and constructing the variable class using its bipartite belt.\n            x0\n            x1\n            (x1^2 + 1)/x0\n            (x1^4 + x0^2 + 2*x1^2 + 1)/(x0^2*x1)\n            (x0^4 + 2*x0^2 + x1^2 + 1)/(x0*x1^2)\n            (x0^2 + 1)/x1\n            (x1^6 + x0^4 + 2*x0^2*x1^2 + 3*x1^4 + 2*x0^2 + 3*x1^2 + 1)/(x0^3*x1^2)\n            (x1^8 + x0^6 + 2*x0^4*x1^2 + 3*x0^2*x1^4 + 4*x1^6 + 3*x0^4 + 6*x0^2*x1^2 + 6*x1^4 + 3*x0^2 + 4*x1^2 + 1)/(x0^4*x1^3)\n            (x0^8 + 4*x0^6 + 3*x0^4*x1^2 + 2*x0^2*x1^4 + x1^6 + 6*x0^4 + 6*x0^2*x1^2 + 3*x1^4 + 4*x0^2 + 3*x1^2 + 1)/(x0^3*x1^4)\n            (x0^6 + 3*x0^4 + 2*x0^2*x1^2 + x1^4 + 3*x0^2 + 2*x1^2 + 1)/(x0^2*x1^3)\n        \"\"\"\n        mut_iter = self.mutation_class_iter( depth=depth,show_depth=False )\n        var_class = set()\n\n        for seed in mut_iter:\n            if seed is self:\n                seed = ClusterSeed(seed)\n            if not ignore_bipartite_belt and seed.is_bipartite():\n                bipartition = seed.is_bipartite(return_bipartition=True)\n                bipartition = (list(bipartition[0]),list(bipartition[1]))\n                if depth is not infinity:\n                    print \"Found a bipartite seed - restarting the depth counter at zero and constructing the variable class using its bipartite belt.\"\n                depth_counter = 0\n                end = False\n                seed2 = ClusterSeed(seed)\n                for c in seed._cluster:\n                    if c not in var_class:\n                        yield ClusterVariable( c.parent(), c.numerator(), c.denominator(), mutation_type=self._mutation_type, variable_type='cluster variable' )\n                var_class = var_class.union( seed._cluster )\n\n                init_cluster = set(seed._cluster)\n                while not end and depth_counter < depth:\n                    depth_counter += 1\n                    seed.mutate(bipartition[0])\n                    seed.mutate(bipartition[1])\n                    if set(seed._cluster) in [set(seed2._cluster),init_cluster]:\n                        end = True\n                    if not end:\n                        for c in seed._cluster:\n                            if c not in var_class:\n                                yield ClusterVariable( c.parent(), c.numerator(), c.denominator(), mutation_type=self._mutation_type, variable_type='cluster variable' )\n                        var_class = var_class.union( seed._cluster )\n                        seed2.mutate(bipartition[1])\n                        seed2.mutate(bipartition[0])\n                        if set(seed2._cluster) in [set(seed._cluster),init_cluster]:\n                            end = True\n                        if not end:\n                            for c in seed2._cluster:\n                                if c not in var_class:\n                                    yield ClusterVariable( c.parent(), c.numerator(), c.denominator(), mutation_type=self._mutation_type, variable_type='cluster variable' )\n                            var_class = var_class.union(seed2._cluster)\n                return\n            else:\n                for c in seed._cluster:\n                    if c not in var_class:\n                        yield ClusterVariable( c.parent(), c.numerator(), c.denominator(), mutation_type=self._mutation_type, variable_type='cluster variable' )\n                var_class = var_class.union(seed._cluster)\n\n    def variable_class(self, depth=infinity, ignore_bipartite_belt=False):\n        r\"\"\"\n        Returns all cluster variables in the mutation class of ``self``.\n\n        INPUT:\n\n            - ``depth`` -- (default:infinity) integer, only seeds with distance at most depth from self are returned\n            - ``ignore_bipartite_belt`` -- (default:False) if True, the algorithms does not use the bipartite belt\n\n\n        EXAMPLES:\n\n        - for examples see :meth:`variable_class_iter`\n\n        TESTS::\n\n            sage: A = ClusterSeed(['A',3]).variable_class()\n        \"\"\"\n        if depth is infinity and not self.is_finite():\n            raise ValueError('The variable class can - for infinite types - only be computed up to a given depth')\n\n        var_iter = self.variable_class_iter( depth=depth, ignore_bipartite_belt=ignore_bipartite_belt )\n        return sorted(var_iter)\n\n    def is_finite( self ):\n        r\"\"\"\n        Returns True if ``self`` is of finite type.\n\n        EXAMPLES::\n\n            sage: S = ClusterSeed(['A',3])\n            sage: S.is_finite()\n            True\n\n            sage: S = ClusterSeed(['A',[2,2],1])\n            sage: S.is_finite()\n            False\n        \"\"\"\n        mt = self.mutation_type()\n        if isinstance(mt, str):\n            return False\n        else:\n            return mt.is_finite()\n\n    def is_mutation_finite( self, nr_of_checks=None, return_path=False ):\n        r\"\"\"\n        Returns True if ``self`` is of finite mutation type.\n\n        INPUT:\n\n        - ``nr_of_checks`` -- (default: None) number of mutations applied. Standard is 500*(number of vertices of self).\n        - ``return_path`` -- (default: False) if True, in case of self not being mutation finite, a path from self to a quiver with an edge label (a,-b) and a*b > 4 is returned.\n\n        ALGORITHM:\n\n        - A cluster seed is mutation infinite if and only if every `b_{ij}*b_{ji} > -4`. Thus, we apply random mutations in random directions\n\n        WARNING:\n\n        - Uses a non-deterministic method by random mutations in various directions.\n        - In theory, it can return a wrong True.\n\n        EXAMPLES::\n\n            sage: S = ClusterSeed(['A',10])\n            sage: S._mutation_type = None\n            sage: S.is_mutation_finite()\n            True\n\n            sage: S = ClusterSeed([(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(2,9)])\n            sage: S.is_mutation_finite()\n            False\n        \"\"\"\n        is_finite, path = is_mutation_finite(copy(self._M),nr_of_checks=nr_of_checks)\n        if return_path:\n            return is_finite, path\n        else:\n            return is_finite\n\n    def mutation_type(self):\n        r\"\"\"\n        Returns the mutation_type of each connected component of ``self``, if it can be determined.\n        Otherwise, the mutation type of this component is set to be unknown.\n\n        The mutation types of the components are ordered by vertex labels.\n\n        WARNING:\n\n        - All finite types can be detected,\n        - All affine types can be detected, EXCEPT affine type D (the algorithm is not yet implemented)\n        - All exceptional types can be detected.\n\n        - Might fail to work if it is used within different Sage processes simultaneously (that happend in the doctesting).\n\n        EXAMPLES:\n\n        - finite types::\n\n            sage: S = ClusterSeed(['A',5])\n            sage: S._mutation_type = S._quiver._mutation_type = None\n            sage: S.mutation_type()\n            ['A', 5]\n\n            sage: S = ClusterSeed([(0,1),(1,2),(2,3),(3,4)])\n            sage: S.mutation_type()\n            ['A', 5]\n\n        - affine types::\n\n            sage: S = ClusterSeed(['E',8,[1,1]]); S\n            A seed for a cluster algebra of rank 10 of type ['E', 8, [1, 1]]\n            sage: S._mutation_type = S._quiver._mutation_type = None; S\n            A seed for a cluster algebra of rank 10\n            sage: S.mutation_type() # long time\n            ['E', 8, [1, 1]]\n\n        - the not yet working affine type D::\n\n            sage: S = ClusterSeed(['D',4,1])\n            sage: S._mutation_type = S._quiver._mutation_type = None\n            sage: S.mutation_type() # todo: not implemented\n            ['D', 4, 1]\n\n        - the exceptional types::\n\n            sage: S = ClusterSeed(['X',6])\n            sage: S._mutation_type = S._quiver._mutation_type = None\n            sage: S.mutation_type() # long time\n            ['X', 6]\n\n        -  infinite types::\n\n            sage: S = ClusterSeed(['GR',[4,9]])\n            sage: S._mutation_type = S._quiver._mutation_type = None\n            sage: S.mutation_type()\n            'undetermined infinite mutation type'\n        \"\"\"\n        if self._mutation_type is None:\n            if self._quiver is None:\n                self.quiver()\n            self._mutation_type = self._quiver.mutation_type()\n        return self._mutation_type\n\n    def greedy(self, a1, a2, method='by_recursion'):\n        r\"\"\"\n        Returns the greedy element `x[a_1,a_2]` assuming that self is rank two.\n\n        The third input can be 'by_recursion', 'by_combinatorics', or\n        'just_numbers' to specify if the user wants the element\n        computed by the recurrence, combinatorial formula, or wants to\n        set `x_1` and `x_2` to be one.\n\n        See [LeeLiZe]_ for more details.\n\n        EXAMPLES::\n\n            sage: S = ClusterSeed(['R2', [3, 3]])\n            sage: S.greedy(4, 4)\n            (x0^12 + x1^12 + 4*x0^9 + 4*x1^9 + 6*x0^6 + 4*x0^3*x1^3 + 6*x1^6 + 4*x0^3 + 4*x1^3 + 1)/(x0^4*x1^4)\n            sage: S.greedy(4, 4, 'by_combinatorics')\n            (x0^12 + x1^12 + 4*x0^9 + 4*x1^9 + 6*x0^6 + 4*x0^3*x1^3 + 6*x1^6 + 4*x0^3 + 4*x1^3 + 1)/(x0^4*x1^4)\n            sage: S.greedy(4, 4, 'just_numbers')\n            35\n            sage: S = ClusterSeed(['R2', [2, 2]])\n            sage: S.greedy(1, 2)\n            (x0^4 + 2*x0^2 + x1^2 + 1)/(x0*x1^2)\n            sage: S.greedy(1, 2, 'by_combinatorics')\n            (x0^4 + 2*x0^2 + x1^2 + 1)/(x0*x1^2)\n\n        REFERENCES:\n\n        .. [LeeLiZe] Lee-Li-Zelevinsky, Greedy elements in rank 2\n           cluster algebras, :arxiv:`1208.2391`\n        \"\"\"\n        if self.b_matrix().dimensions() == (2, 2):\n            b = abs(self.b_matrix()[0, 1])\n            c = abs(self.b_matrix()[1, 0])\n            if method == 'by_recursion':\n                ans = self.x(0)**(-a1)*self.x(1)**(-a2)\n                for p in range(max(a2, 0)+1):\n                    for q in range(max(a1, 0)+1):\n                        if p != 0 or q != 0:\n                            ans += self._R(coeff_recurs(p, q, a1, a2, b, c))*self.x(0)**(b*p-a1)*self.x(1)**(c*q-a2)\n                return(ans)\n            elif method == 'by_combinatorics':\n                if b == 0:\n                    S = ClusterSeed([['A', 1], ['A', 1]])\n                else:\n                    S = ClusterSeed(['R2', [b, b]])\n                ans = 0\n                if a1 >= a2:\n                    PS = PathSubset(a1, a2)\n                elif a1 < a2:\n                    PS = PathSubset(a2, a1)\n                from sage.combinat.subset import Subsets\n                for T in Subsets(PS):\n                    if a1 >= a2:\n                        if is_LeeLiZel_allowable(T, a1, a2, b, c):\n                            oddT = set(T).intersection(PathSubset(a1, 0))\n                            evenT = set(T).symmetric_difference(oddT)\n                            ans = ans + S.x(0)**(b*len(evenT)) * S.x(1)**(c*len(oddT))\n                    elif a1 < a2:\n                        if is_LeeLiZel_allowable(T, a2, a1, b, c):\n                            oddT = set(T).intersection(PathSubset(a2, 0))\n                            evenT = set(T).symmetric_difference(oddT)\n                            ans = ans + S.x(0)**(b*len(oddT)) * S.x(1)**(c*len(evenT))\n                ans = ans*S.x(0)**(-a1)*S.x(1)**(-a2)\n                return ans\n            elif method == 'just_numbers':\n                ans = 1\n                for p in range(max(a2, 0)+1):\n                    for q in range(max(a1, 0)+1):\n                        if p != 0 or q != 0:\n                            ans += coeff_recurs(p, q, a1, a2, b, c)\n                return(ans)\n            else:\n                raise ValueError(\"The third input should be 'by_recursion', \"\n                                 \"'by_combinatorics', or 'just_numbers'.\")\n        else:\n            raise ValueError(\"Greedy elements are only currently \"\n                             \"defined for cluster seeds of rank two.\")\n","mode":"python","lineno":-1,"filename":null}}︡
︠b47e7440-2d95-4459-a0d4-dd28ba2e798fos︠
S = ClusterSeed(B); S
︡52eb1700-7505-4c0a-abd5-703c6e00dd98︡{"stdout":"A seed for a cluster algebra of rank 2\n"}︡
︠39bcca66-3432-4299-8237-97c637a7304fos︠
S.mutation_type()
︡005a28ab-f925-4f6b-8358-288598280b36︡{"stdout":"['A', 2]\n"}︡
︠ef934691-260c-47f3-9254-3529313d94e6os︠
S
︡c59f2885-3159-402a-8666-1a32f6e0ad8d︡{"stdout":"A seed for a cluster algebra of rank 2 of type ['A', 2]\n"}︡
︠e9b66c5b-8074-43b9-8696-c384db173898os︠
S.is_finite()
︡f97b72d8-1808-4800-bdee-ad51145156bb︡{"stdout":"True\n"}︡
︠1cf9ef40-1c51-433f-86fa-23bb0fbc441eos︠
S.is_mutation_finite()
︡63d4f943-8f1f-4271-a4ec-1f890caf421a︡{"stdout":"True\n"}︡
︠a174631d-7c63-4b9f-b344-7af73b15aaeaos︠
S.is_acyclic()
︡f6971f10-efa9-4835-b29e-860dcba01644︡{"stdout":"True\n"}︡
︠53e54d7b-294b-4d63-91ce-ba72a77bb4beos︠
S.is_bipartite()
︡85186523-a92d-46e7-a08c-72aaffc63d00︡{"stdout":"True\n"}︡
︠81a81bc6-7cac-4168-a3aa-a91f7f8b4ab5os︠
S.show()
︡3c86cdad-7867-4e12-85ff-1e1c933e57d8︡{"once":false,"file":{"show":true,"uuid":"ba66b6f9-1720-4798-bb0f-90ab326ae916","filename":"/projects/02aac756-d7ee-4d37-9546-ef8d58152220/.sage/temp/compute2-us/30002/tmp_6HA83t.svg"}}︡{"html":"<div align='center'></div>"}︡
︠bf683423-3581-401c-b79b-7fbd30193989os︠
S.cluster()
︡51765029-17e7-463b-b822-2c314a11f2ea︡{"stdout":"[x0, x1]\n"}︡
︠fb38776d-3af3-40ac-aea9-b318d80d4474os︠
S.mutate(0); S.cluster()
︡a7469639-10f5-4450-9e94-26a6ffd62a3a︡{"stdout":"[(x1 + 1)/x0, x1]\n"}︡
︠f9c9106c-cac4-4d8a-a5d2-929bbe646001os︠
S.mutate(1); S.cluster()
︡20425d96-4089-43fa-91ef-5dd7324541ce︡{"stdout":"[(x1 + 1)/x0, (x0 + x1 + 1)/(x0*x1)]\n"}︡
︠9e8a0144-3f83-4764-ab52-73bb364294eeos︠
S.mutate([0,1]); S.cluster()
︡cce28f3c-ac2c-4e34-8e2c-a02970c8704a︡{"stdout":"[(x0 + 1)/x1, x0]\n"}︡
︠b77a1219-ae4a-43ff-a5e6-8c2efc3945c8os︠
S.variable_class()
︡ca9ed1b4-c0c0-46dd-ae05-f5062e0d4d15︡{"stdout":"[(x0 + x1 + 1)/(x0*x1), (x1 + 1)/x0, (x0 + 1)/x1, x1, x0]\n"}︡
︠1f342997-da3c-4898-8dfd-3d11ca0d709fos︠
S.cluster()
︡8ada5cc3-b10d-43c6-8023-205cc109ab61︡{"stdout":"[(x0 + 1)/x1, x0]\n"}︡
︠c8d503d0-368e-4c3c-a766-4ed68f5a1d2bos︠
S.reset_cluster()
︡ecd337e8-5cc0-451b-91d8-8f671693fb5d︡
︠adc5636f-b950-4e70-9e32-241a1d5424c7os︠
SP = S.principal_extension(); SP
︡da87e6b7-5433-4475-80d4-f74a5a8ef469︡{"stdout":"A seed for a cluster algebra of rank 2 of type ['A', 2] with principal coefficients\n"}︡
︠3c5882db-bf06-451b-af73-0b282e37b0ccos︠
SP.b_matrix(); SP.cluster()
︡0deb8bcb-eb12-4ca4-bdca-de64bea5a1cf︡{"stdout":"[ 0  1]\n[-1  0]\n[ 1  0]\n[ 0  1]\n[x0, x1]\n"}︡
︠c8311db1-249a-41b2-ac68-9896e6d21bd3os︠
SP.variable_class()
︡fa897866-7cc3-496d-8300-c67d8390b700︡{"stdout":"[(x1 + y0)/x0, (x0*y0*y1 + x1 + y0)/(x0*x1), y1, (x0*y1 + 1)/x1, y0, x1, x0]\n"}︡
︠07b34837-97d7-4aae-938b-f150ec80c17bos︠
SP.set_cluster([SP.x(0)+SP.x(1),SP.x(0)^2+1,SP.y(0),SP.y(1)])
︡b68fc70e-9def-42d8-9278-dd763edc5ce3︡
︠f7f2c0dc-5759-4c44-813e-9863feeeb5b4os︠
SP.mutation_sequence([0,1,0,1,0],return_output='Mat')
︡e2525848-1fbf-4425-847c-2fff7a98a22f︡{"stderr":"Error in lines 1-1\nTraceback (most recent call last):\n  File \"/projects/02aac756-d7ee-4d37-9546-ef8d58152220/.sagemathcloud/sage_server.py\", line 879, in execute\n    exec compile(block+'\\n', '', 'single') in namespace, locals\n  File \"\", line 1, in <module>\n  File \"/projects/sage/sage-6.7/local/lib/python2.7/site-packages/sage/combinat/cluster_algebra_quiver/cluster_seed.py\", line 892, in mutation_sequence\n    raise ValueError('The parameter `return_output` can only be `seed`, `matrix`, or `var`.')\nValueError: The parameter `return_output` can only be `seed`, `matrix`, or `var`.\n"}︡
︠4d5d1a84-99ac-416f-b96e-12da812708a4os︠
SP.mutation_sequence([0,1,0,1,0],return_output='matrix')
︡58962d90-c011-4b9c-93db-6df9ceb33b4c︡{"stdout":"[[ 0 -1]\n[ 1  0]\n[-1  1]\n[ 0  1], [ 0  1]\n[-1  0]\n[ 0 -1]\n[ 1 -1], [ 0 -1]\n[ 1  0]\n[ 0 -1]\n[-1  0], [ 0  1]\n[-1  0]\n[ 0  1]\n[-1  0], [ 0 -1]\n[ 1  0]\n[ 0  1]\n[ 1  0]]\n"}︡
︠800195f5-4def-49a2-81b9-e80ae8ddf446os︠
Fpolys = SP.variable_class(); Fpolys
︡5f7678d8-587b-49d1-b729-4157f4c9d6c7︡{"stdout":"[(x0*y0*y1 + x1*y0*y1 + x0^2 + y0 + 1)/(x0^3 + x0^2*x1 + x0 + x1), (x0*y1 + x1*y1 + 1)/(x0^2 + 1), y1, y0, (x0^2 + y0 + 1)/(x0 + x1), x0 + x1, x0^2 + 1]\n"}︡
︠7b137c40-67cc-4ed1-ba30-ce6f718a7fe4os︠
SP.cluster()
︡0188e09c-dec0-45ab-b1d8-cb4988f83530︡{"stdout":"[x0 + x1, x0^2 + 1]\n"}︡
︠bb7cfbbb-3bfc-4f22-bd21-70c2788d6d3fos︠
SP.set_cluster([1,1,SP.y(0),SP.y(1)]); SP.cluster()
︡7dfa4cae-59a2-4e14-b10e-85b9d9e05e35︡{"stdout":"[1, 1]\n"}︡
︠0b0c8cc1-d72e-4363-8c44-16d62d11b944os︠
S2 = ClusterSeed(['A',[1,1],1]); S2
︡5f640858-5d14-4d76-b219-824f7bdc3ed8︡{"stdout":"A seed for a cluster algebra of rank 2 of type ['A', [1, 1], 1]\n"}︡
︠0192f30d-abf4-439d-9331-d7bcf12469cfos︠
S2.b_matrix()
︡881a1e28-067e-499d-80a4-4873de17a3c9︡{"stdout":"[ 0  2]\n[-2  0]\n"}︡
︠41786ff2-ec51-4596-9695-af5f246762b8os︠
S2.show()
︡f1b12acf-e05b-49f6-b009-ffac382701c3︡{"once":false,"file":{"show":true,"uuid":"cf566473-b97b-4781-bd72-b0bfab16ad87","filename":"/projects/02aac756-d7ee-4d37-9546-ef8d58152220/.sage/temp/compute2-us/30002/tmp_Tyl8Po.svg"}}︡{"html":"<div align='center'></div>"}︡
︠b05ba4f5-8f01-443d-9eaf-6fc5789b22baos︠
S2.cluster()
︡74a3f79e-c0c8-4d6d-825d-7011d125ac28︡{"stdout":"[x0, x1]\n"}︡
︠6f3d68ef-f5c6-48b0-b060-47f8c0d3a7d8os︠
S2.mutate([0,1]); S2.cluster()
︡cd641a15-b432-441a-a384-f1dfe707b3ac︡{"stdout":"[(x1^2 + 1)/x0, (x1^4 + x0^2 + 2*x1^2 + 1)/(x0^2*x1)]\n"}︡
︠6591abdb-3574-4fa3-aa5c-a3085d9bef1eos︠
S2.mutate([0,1]); S2.cluster()
︡0606c0e4-6567-473e-9003-3be2d6807118︡{"stdout":"[(x1^6 + x0^4 + 2*x0^2*x1^2 + 3*x1^4 + 2*x0^2 + 3*x1^2 + 1)/(x0^3*x1^2), (x1^8 + x0^6 + 2*x0^4*x1^2 + 3*x0^2*x1^4 + 4*x1^6 + 3*x0^4 + 6*x0^2*x1^2 + 6*x1^4 + 3*x0^2 + 4*x1^2 + 1)/(x0^4*x1^3)]\n"}︡
︠d7d4936d-c741-4bfc-b8e5-90cf197648cfos︠
S2.mutate([0,1]); S2.cluster()
︡0ca4caaa-a7df-49d2-aa73-cc3aec274537︡{"stdout":"[(x1^10 + x0^8 + 2*x0^6*x1^2 + 3*x0^4*x1^4 + 4*x0^2*x1^6 + 5*x1^8 + 4*x0^6 + 9*x0^4*x1^2 + 12*x0^2*x1^4 + 10*x1^6 + 6*x0^4 + 12*x0^2*x1^2 + 10*x1^4 + 4*x0^2 + 5*x1^2 + 1)/(x0^5*x1^4), (x1^12 + x0^10 + 2*x0^8*x1^2 + 3*x0^6*x1^4 + 4*x0^4*x1^6 + 5*x0^2*x1^8 + 6*x1^10 + 5*x0^8 + 12*x0^6*x1^2 + 18*x0^4*x1^4 + 20*x0^2*x1^6 + 15*x1^8 + 10*x0^6 + 24*x0^4*x1^2 + 30*x0^2*x1^4 + 20*x1^6 + 10*x0^4 + 20*x0^2*x1^2 + 15*x1^4 + 5*x0^2 + 6*x1^2 + 1)/(x0^6*x1^5)]\n"}︡
︠fd6633b7-de05-4bf2-82ec-321520e15d17os︠
latex( S2.cluster() )
︡3b0f71c0-16d4-4dee-a998-8d160ab7c132︡{"stdout":"\\left[\\frac{x_{1}^{10} + x_{0}^{8} + 2 x_{0}^{6} x_{1}^{2} + 3 x_{0}^{4} x_{1}^{4} + 4 x_{0}^{2} x_{1}^{6} + 5 x_{1}^{8} + 4 x_{0}^{6} + 9 x_{0}^{4} x_{1}^{2} + 12 x_{0}^{2} x_{1}^{4} + 10 x_{1}^{6} + 6 x_{0}^{4} + 12 x_{0}^{2} x_{1}^{2} + 10 x_{1}^{4} + 4 x_{0}^{2} + 5 x_{1}^{2} + 1}{x_{0}^{5} x_{1}^{4}}, \\frac{x_{1}^{12} + x_{0}^{10} + 2 x_{0}^{8} x_{1}^{2} + 3 x_{0}^{6} x_{1}^{4} + 4 x_{0}^{4} x_{1}^{6} + 5 x_{0}^{2} x_{1}^{8} + 6 x_{1}^{10} + 5 x_{0}^{8} + 12 x_{0}^{6} x_{1}^{2} + 18 x_{0}^{4} x_{1}^{4} + 20 x_{0}^{2} x_{1}^{6} + 15 x_{1}^{8} + 10 x_{0}^{6} + 24 x_{0}^{4} x_{1}^{2} + 30 x_{0}^{2} x_{1}^{4} + 20 x_{1}^{6} + 10 x_{0}^{4} + 20 x_{0}^{2} x_{1}^{2} + 15 x_{1}^{4} + 5 x_{0}^{2} + 6 x_{1}^{2} + 1}{x_{0}^{6} x_{1}^{5}}\\right]\n"}︡
︠2fb31790-ec7d-42a8-9be3-a6e922576868os︠
S2.variable_class()
︡d161e04d-9e49-4761-a97d-8955502ee574︡{"stderr":"Error in lines 1-1\nTraceback (most recent call last):\n  File \"/projects/02aac756-d7ee-4d37-9546-ef8d58152220/.sagemathcloud/sage_server.py\", line 879, in execute\n    exec compile(block+'\\n', '', 'single') in namespace, locals\n  File \"\", line 1, in <module>\n  File \"/projects/sage/sage-6.7/local/lib/python2.7/site-packages/sage/combinat/cluster_algebra_quiver/cluster_seed.py\", line 1834, in variable_class\n    raise ValueError('The variable class can - for infinite types - only be computed up to a given depth')\nValueError: The variable class can - for infinite types - only be computed up to a given depth\n"}︡
︠e3e3912a-ef8f-4b2a-8dad-5f330661196aos︠
S2.variable_class(depth=3)
︡7f891182-a4c0-4bcc-9a72-81549d96afa3︡{"stdout":"Found a bipartite seed - restarting the depth counter at zero and constructing the variable class using its bipartite belt.\n[(x1^24 + x0^22 + 2*x0^20*x1^2 + 3*x0^18*x1^4 + 4*x0^16*x1^6 + 5*x0^14*x1^8 + 6*x0^12*x1^10 + 7*x0^10*x1^12 + 8*x0^8*x1^14 + 9*x0^6*x1^16 + 10*x0^4*x1^18 + 11*x0^2*x1^20 + 12*x1^22 + 11*x0^20 + 30*x0^18*x1^2 + 54*x0^16*x1^4 + 80*x0^14*x1^6 + 105*x0^12*x1^8 + 126*x0^10*x1^10 + 140*x0^8*x1^12 + 144*x0^6*x1^14 + 135*x0^4*x1^16 + 110*x0^2*x1^18 + 66*x1^20 + 55*x0^18 + 180*x0^16*x1^2 + 360*x0^14*x1^4 + 560*x0^12*x1^6 + 735*x0^10*x1^8 + 840*x0^8*x1^10 + 840*x0^6*x1^12 + 720*x0^4*x1^14 + 495*x0^2*x1^16 + 220*x1^18 + 165*x0^16 + 600*x0^14*x1^2 + 1260*x0^12*x1^4 + 1960*x0^10*x1^6 + 2450*x0^8*x1^8 + 2520*x0^6*x1^10 + 2100*x0^4*x1^12 + 1320*x0^2*x1^14 + 495*x1^16 + 330*x0^14 + 1260*x0^12*x1^2 + 2646*x0^10*x1^4 + 3920*x0^8*x1^6 + 4410*x0^6*x1^8 + 3780*x0^4*x1^10 + 2310*x0^2*x1^12 + 792*x1^14 + 462*x0^12 + 1764*x0^10*x1^2 + 3528*x0^8*x1^4 + 4704*x0^6*x1^6 + 4410*x0^4*x1^8 + 2772*x0^2*x1^10 + 924*x1^12 + 462*x0^10 + 1680*x0^8*x1^2 + 3024*x0^6*x1^4 + 3360*x0^4*x1^6 + 2310*x0^2*x1^8 + 792*x1^10 + 330*x0^8 + 1080*x0^6*x1^2 + 1620*x0^4*x1^4 + 1320*x0^2*x1^6 + 495*x1^8 + 165*x0^6 + 450*x0^4*x1^2 + 495*x0^2*x1^4 + 220*x1^6 + 55*x0^4 + 110*x0^2*x1^2 + 66*x1^4 + 11*x0^2 + 12*x1^2 + 1)/(x0^12*x1^11), (x1^22 + x0^20 + 2*x0^18*x1^2 + 3*x0^16*x1^4 + 4*x0^14*x1^6 + 5*x0^12*x1^8 + 6*x0^10*x1^10 + 7*x0^8*x1^12 + 8*x0^6*x1^14 + 9*x0^4*x1^16 + 10*x0^2*x1^18 + 11*x1^20 + 10*x0^18 + 27*x0^16*x1^2 + 48*x0^14*x1^4 + 70*x0^12*x1^6 + 90*x0^10*x1^8 + 105*x0^8*x1^10 + 112*x0^6*x1^12 + 108*x0^4*x1^14 + 90*x0^2*x1^16 + 55*x1^18 + 45*x0^16 + 144*x0^14*x1^2 + 280*x0^12*x1^4 + 420*x0^10*x1^6 + 525*x0^8*x1^8 + 560*x0^6*x1^10 + 504*x0^4*x1^12 + 360*x0^2*x1^14 + 165*x1^16 + 120*x0^14 + 420*x0^12*x1^2 + 840*x0^10*x1^4 + 1225*x0^8*x1^6 + 1400*x0^6*x1^8 + 1260*x0^4*x1^10 + 840*x0^2*x1^12 + 330*x1^14 + 210*x0^12 + 756*x0^10*x1^2 + 1470*x0^8*x1^4 + 1960*x0^6*x1^6 + 1890*x0^4*x1^8 + 1260*x0^2*x1^10 + 462*x1^12 + 252*x0^10 + 882*x0^8*x1^2 + 1568*x0^6*x1^4 + 1764*x0^4*x1^6 + 1260*x0^2*x1^8 + 462*x1^10 + 210*x0^8 + 672*x0^6*x1^2 + 1008*x0^4*x1^4 + 840*x0^2*x1^6 + 330*x1^8 + 120*x0^6 + 324*x0^4*x1^2 + 360*x0^2*x1^4 + 165*x1^6 + 45*x0^4 + 90*x0^2*x1^2 + 55*x1^4 + 10*x0^2 + 11*x1^2 + 1)/(x0^11*x1^10), (x1^20 + x0^18 + 2*x0^16*x1^2 + 3*x0^14*x1^4 + 4*x0^12*x1^6 + 5*x0^10*x1^8 + 6*x0^8*x1^10 + 7*x0^6*x1^12 + 8*x0^4*x1^14 + 9*x0^2*x1^16 + 10*x1^18 + 9*x0^16 + 24*x0^14*x1^2 + 42*x0^12*x1^4 + 60*x0^10*x1^6 + 75*x0^8*x1^8 + 84*x0^6*x1^10 + 84*x0^4*x1^12 + 72*x0^2*x1^14 + 45*x1^16 + 36*x0^14 + 112*x0^12*x1^2 + 210*x0^10*x1^4 + 300*x0^8*x1^6 + 350*x0^6*x1^8 + 336*x0^4*x1^10 + 252*x0^2*x1^12 + 120*x1^14 + 84*x0^12 + 280*x0^10*x1^2 + 525*x0^8*x1^4 + 700*x0^6*x1^6 + 700*x0^4*x1^8 + 504*x0^2*x1^10 + 210*x1^12 + 126*x0^10 + 420*x0^8*x1^2 + 735*x0^6*x1^4 + 840*x0^4*x1^6 + 630*x0^2*x1^8 + 252*x1^10 + 126*x0^8 + 392*x0^6*x1^2 + 588*x0^4*x1^4 + 504*x0^2*x1^6 + 210*x1^8 + 84*x0^6 + 224*x0^4*x1^2 + 252*x0^2*x1^4 + 120*x1^6 + 36*x0^4 + 72*x0^2*x1^2 + 45*x1^4 + 9*x0^2 + 10*x1^2 + 1)/(x0^10*x1^9), (x1^18 + x0^16 + 2*x0^14*x1^2 + 3*x0^12*x1^4 + 4*x0^10*x1^6 + 5*x0^8*x1^8 + 6*x0^6*x1^10 + 7*x0^4*x1^12 + 8*x0^2*x1^14 + 9*x1^16 + 8*x0^14 + 21*x0^12*x1^2 + 36*x0^10*x1^4 + 50*x0^8*x1^6 + 60*x0^6*x1^8 + 63*x0^4*x1^10 + 56*x0^2*x1^12 + 36*x1^14 + 28*x0^12 + 84*x0^10*x1^2 + 150*x0^8*x1^4 + 200*x0^6*x1^6 + 210*x0^4*x1^8 + 168*x0^2*x1^10 + 84*x1^12 + 56*x0^10 + 175*x0^8*x1^2 + 300*x0^6*x1^4 + 350*x0^4*x1^6 + 280*x0^2*x1^8 + 126*x1^10 + 70*x0^8 + 210*x0^6*x1^2 + 315*x0^4*x1^4 + 280*x0^2*x1^6 + 126*x1^8 + 56*x0^6 + 147*x0^4*x1^2 + 168*x0^2*x1^4 + 84*x1^6 + 28*x0^4 + 56*x0^2*x1^2 + 36*x1^4 + 8*x0^2 + 9*x1^2 + 1)/(x0^9*x1^8), (x1^16 + x0^14 + 2*x0^12*x1^2 + 3*x0^10*x1^4 + 4*x0^8*x1^6 + 5*x0^6*x1^8 + 6*x0^4*x1^10 + 7*x0^2*x1^12 + 8*x1^14 + 7*x0^12 + 18*x0^10*x1^2 + 30*x0^8*x1^4 + 40*x0^6*x1^6 + 45*x0^4*x1^8 + 42*x0^2*x1^10 + 28*x1^12 + 21*x0^10 + 60*x0^8*x1^2 + 100*x0^6*x1^4 + 120*x0^4*x1^6 + 105*x0^2*x1^8 + 56*x1^10 + 35*x0^8 + 100*x0^6*x1^2 + 150*x0^4*x1^4 + 140*x0^2*x1^6 + 70*x1^8 + 35*x0^6 + 90*x0^4*x1^2 + 105*x0^2*x1^4 + 56*x1^6 + 21*x0^4 + 42*x0^2*x1^2 + 28*x1^4 + 7*x0^2 + 8*x1^2 + 1)/(x0^8*x1^7), (x1^14 + x0^12 + 2*x0^10*x1^2 + 3*x0^8*x1^4 + 4*x0^6*x1^6 + 5*x0^4*x1^8 + 6*x0^2*x1^10 + 7*x1^12 + 6*x0^10 + 15*x0^8*x1^2 + 24*x0^6*x1^4 + 30*x0^4*x1^6 + 30*x0^2*x1^8 + 21*x1^10 + 15*x0^8 + 40*x0^6*x1^2 + 60*x0^4*x1^4 + 60*x0^2*x1^6 + 35*x1^8 + 20*x0^6 + 50*x0^4*x1^2 + 60*x0^2*x1^4 + 35*x1^6 + 15*x0^4 + 30*x0^2*x1^2 + 21*x1^4 + 6*x0^2 + 7*x1^2 + 1)/(x0^7*x1^6), (x1^12 + x0^10 + 2*x0^8*x1^2 + 3*x0^6*x1^4 + 4*x0^4*x1^6 + 5*x0^2*x1^8 + 6*x1^10 + 5*x0^8 + 12*x0^6*x1^2 + 18*x0^4*x1^4 + 20*x0^2*x1^6 + 15*x1^8 + 10*x0^6 + 24*x0^4*x1^2 + 30*x0^2*x1^4 + 20*x1^6 + 10*x0^4 + 20*x0^2*x1^2 + 15*x1^4 + 5*x0^2 + 6*x1^2 + 1)/(x0^6*x1^5), (x1^10 + x0^8 + 2*x0^6*x1^2 + 3*x0^4*x1^4 + 4*x0^2*x1^6 + 5*x1^8 + 4*x0^6 + 9*x0^4*x1^2 + 12*x0^2*x1^4 + 10*x1^6 + 6*x0^4 + 12*x0^2*x1^2 + 10*x1^4 + 4*x0^2 + 5*x1^2 + 1)/(x0^5*x1^4), (x1^8 + x0^6 + 2*x0^4*x1^2 + 3*x0^2*x1^4 + 4*x1^6 + 3*x0^4 + 6*x0^2*x1^2 + 6*x1^4 + 3*x0^2 + 4*x1^2 + 1)/(x0^4*x1^3), (x1^6 + x0^4 + 2*x0^2*x1^2 + 3*x1^4 + 2*x0^2 + 3*x1^2 + 1)/(x0^3*x1^2), (x1^4 + x0^2 + 2*x1^2 + 1)/(x0^2*x1), (x1^2 + 1)/x0, x1, x0]"}︡{"stdout":"\n"}︡
︠d8d3b8a1-64ca-4df7-b1c2-6b6f5476aec1os︠
S2.b_matrix_class(); S2.b_matrix_class(up_to_equivalence=False)
︡94227a6c-ab9d-416e-93c8-74c27df709fd︡{"stdout":"[[ 0  2]\n[-2  0]]\n[[ 0  2]\n[-2  0], [ 0 -2]\n[ 2  0]]\n"}︡
︠8701bcb2-b454-4a38-8010-ccb800901220os︠
VV = S2.variable_class(depth=3); DD = map(denominator,VV); DD
︡748cf16b-a95a-4f72-8ca4-d4b5705f8b77︡{"stdout":"Found a bipartite seed - restarting the depth counter at zero and constructing the variable class using its bipartite belt.\n[x0^12*x1^11, x0^11*x1^10, x0^10*x1^9, x0^9*x1^8, x0^8*x1^7, x0^7*x1^6, x0^6*x1^5, x0^5*x1^4, x0^4*x1^3, x0^3*x1^2, x0^2*x1, x0, 1, 1]\n"}︡
︠54e0f70c-a485-4a4a-b494-db91d1d8134fos︠
[monom.degrees() for monom in DD]
︡17c85f6a-99f7-41af-b24a-9c24460ff6d6︡{"stdout":"[(12, 11), (11, 10), (10, 9), (9, 8), (8, 7), (7, 6), (6, 5), (5, 4), (4, 3), (3, 2), (2, 1), (1, 0), (0, 0), (0, 0)]\n"}︡
︠5ad2e86d-8491-43df-a96d-62ea37790b79os︠
S33 = ClusterSeed(['A',[3,3],1]); S33
︡a2b89f9a-a466-48c9-9a08-42158f38f360︡{"stdout":"A seed for a cluster algebra of rank 6 of type ['A', [3, 3], 1]\n"}︡
︠025271d6-ac6e-480d-9be4-5f1d59ee2e92os︠
S33.show()
︡a30ff1ec-5bdf-4bcc-96e7-1fa2669583b7︡{"once":false,"file":{"show":true,"uuid":"47705f70-24b7-4353-b3c5-5b5c05ba173a","filename":"/projects/02aac756-d7ee-4d37-9546-ef8d58152220/.sage/temp/compute2-us/30002/tmp_OGCZUn.svg"}}︡{"html":"<div align='center'></div>"}︡
︠6e3a9514-4e8a-47ad-aff5-b1441f3c8716os︠
MC = S33.b_matrix_class(); MC
︡1d36f8d7-a8ff-41be-b8bf-9b390ccad313︡{"stdout":"[[ 0  0  0  0  1  1]\n[ 0  0  0  1  0  1]\n[ 0  0  0  1  1  0]\n[ 0 -1 -1  0  0  0]\n[-1  0 -1  0  0  0]\n[-1 -1  0  0  0  0], [ 0  0  0  1  1  0]\n[ 0  0  1  0  1  0]\n[ 0 -1  0  0  0  1]\n[-1  0  0  0  0  1]\n[-1 -1  0  0  0  0]\n[ 0  0 -1 -1  0  0], [ 0  0  0  0  1  1]\n[ 0  0  1  1  0  0]\n[ 0 -1  0  0  0  1]\n[ 0 -1  0  0  1  0]\n[-1  0  0 -1  0  0]\n[-1  0 -1  0  0  0], [ 0  0  1  0  0  1]\n[ 0  0  0 -1  1  1]\n[-1  0  0  0  1  0]\n[ 0  1  0  0 -1  0]\n[ 0 -1 -1  1  0  0]\n[-1 -1  0  0  0  0], [ 0  0  0  1  1  0]\n[ 0  0  0  0 -1  1]\n[ 0  0  0 -1  0  1]\n[-1  0  1  0  0  0]\n[-1  1  0  0  0  0]\n[ 0 -1 -1  0  0  0], [ 0  0  0  0  1  1]\n[ 0  0  0 -1  1  0]\n[ 0  0  0  1  0 -1]\n[ 0  1 -1  0  0  1]\n[-1 -1  0  0  0  0]\n[-1  0  1 -1  0  0], [ 0  0  0  1  1  0]\n[ 0  0  0 -1  0  1]\n[ 0  0  0  0  1 -1]\n[-1  1  0  0  0  0]\n[-1  0 -1  0  0  1]\n[ 0 -1  1  0 -1  0], [ 0  0  0 -1  1  1]\n[ 0  0 -1  0  1  1]\n[ 0  1  0  0  0 -1]\n[ 1  0  0  0  0 -1]\n[-1 -1  0  0  0  0]\n[-1 -1  1  1  0  0], [ 0  0 -1  0  0  1]\n[ 0  0  0 -1  1  0]\n[ 1  0  0  0 -1  0]\n[ 0  1  0  0 -1  1]\n[ 0 -1  1  1  0  0]\n[-1  0  0 -1  0  0], [ 0  0  0  1  1  0]\n[ 0  0  0  0 -1  1]\n[ 0  0  0 -1  0  1]\n[-1  0  1  0  0 -1]\n[-1  1  0  0  0 -1]\n[ 0 -1 -1  1  1  0], [ 0  0  0 -1  1  0]\n[ 0  0 -1  0  1  0]\n[ 0  1  0  0 -1  1]\n[ 1  0  0  0 -1  1]\n[-1 -1  1  1  0  0]\n[ 0  0 -1 -1  0  0], [ 0  0  0  0  1 -1]\n[ 0  0 -1  1  0  0]\n[ 0  1  0 -1  0  1]\n[ 0 -1  1  0  1  0]\n[-1  0  0 -1  0  1]\n[ 1  0 -1  0 -1  0], [ 0  0  0  0  0  1]\n[ 0  0 -1  0  1  0]\n[ 0  1  0 -1  0  0]\n[ 0  0  1  0  1 -1]\n[ 0 -1  0 -1  0  1]\n[-1  0  0  1 -1  0], [ 0  0  0  0  1  1]\n[ 0  0  0 -1  0  1]\n[ 0  0  0 -1  1  0]\n[ 0  1  1  0 -1 -1]\n[-1  0 -1  1  0  0]\n[-1 -1  0  1  0  0], [ 0  0  0  0 -1  0]\n[ 0  0 -1  0  0  1]\n[ 0  1  0 -1  0  0]\n[ 0  0  1  0 -1  1]\n[ 1  0  0  1  0 -1]\n[ 0 -1  0 -1  1  0], [ 0  0  0 -1  0  0]\n[ 0  0 -1  0  1  0]\n[ 0  1  0  0 -1  1]\n[ 1  0  0  0  1 -1]\n[ 0 -1  1 -1  0  1]\n[ 0  0 -1  1 -1  0], [ 0  0  0 -1  0  0]\n[ 0  0  0  0  1 -1]\n[ 0  0  0 -1  1  1]\n[ 1  0  1  0  0 -1]\n[ 0 -1 -1  0  0  1]\n[ 0  1 -1  1 -1  0], [ 0  0  0  0  0  1]\n[ 0  0  1 -1  1  0]\n[ 0 -1  0  1  0  0]\n[ 0  1 -1  0  1 -1]\n[ 0 -1  0 -1  0  1]\n[-1  0  0  1 -1  0], [ 0  0  0  1  0  0]\n[ 0  0  0  0 -1  1]\n[ 0  0  0 -1  1  1]\n[-1  0  1  0 -1  0]\n[ 0  1 -1  1  0 -1]\n[ 0 -1 -1  0  1  0], [ 0  0  0  1  1 -2]\n[ 0  0  0  0 -1  0]\n[ 0  0  0 -1  0  0]\n[-1  0  1  0  0  1]\n[-1  1  0  0  0  1]\n[ 2  0  0 -1 -1  0], [ 0  0  0  0  1  0]\n[ 0  0  0  1  0  0]\n[ 0  0  0  1  1 -2]\n[ 0 -1 -1  0  0  1]\n[-1  0 -1  0  0  1]\n[ 0  0  2 -1 -1  0], [ 0  0  0  0  1  0]\n[ 0  0  1  0  1 -2]\n[ 0 -1  0  1  0  1]\n[ 0  0 -1  0  0  0]\n[-1 -1  0  0  0  1]\n[ 0  2 -1  0 -1  0]]"}︡{"stdout":"\n"}︡
︠1608a7e0-0c3a-4b2c-a4b6-88da961c91a5os︠
B = MC[5]; B
︡18eaf6c8-7a25-48ef-b41d-c274f4daaa07︡{"stdout":"[ 0  0  0  0  1  1]\n[ 0  0  0 -1  1  0]\n[ 0  0  0  1  0 -1]\n[ 0  1 -1  0  0  1]\n[-1 -1  0  0  0  0]\n[-1  0  1 -1  0  0]\n"}︡
︠d6544a68-6604-4cb3-9938-d87bc1ed2a7fos︠
Snew = ClusterSeed(B); Snew; Snew.show()
︡32fd5ef7-a5f9-4505-b323-b4f1bbf74e41︡{"stdout":"A seed for a cluster algebra of rank 6\n"}︡{"once":false,"file":{"show":true,"uuid":"70a2aa39-3e10-4eac-9e17-67e58a0297a9","filename":"/projects/02aac756-d7ee-4d37-9546-ef8d58152220/.sage/temp/compute2-us/30002/tmp_V7TSJv.svg"}}︡{"html":"<div align='center'></div>"}︡
︠d7bb6325-a354-44df-a275-f97bf0b8562dos︠
Snew2 = Snew.principal_extension(); Snew2; Snew2.show()
︡0803584c-7160-4968-802e-31d21b7c5f28︡{"stdout":"A seed for a cluster algebra of rank 6 with principal coefficients\n"}︡{"once":false,"file":{"show":true,"uuid":"d8f7d918-b3b8-407b-856b-1156bd0f5ccb","filename":"/projects/02aac756-d7ee-4d37-9546-ef8d58152220/.sage/temp/compute2-us/30002/tmp_yKysJe.svg"}}︡{"html":"<div align='center'></div>"}︡
︠f38263c9-5b9e-418a-b96a-68d0e8e885dbos︠
Snew2.mutation_type()
︡05e295f8-77aa-428d-b6ba-fe467b33b970︡{"stdout":"['A', [3, 3], 1]\n"}︡
︠d2361e5f-e280-4bef-8e72-33ce4921d40bos︠
Snew2
︡233a754d-5746-4c3f-b779-bede97e4243c︡{"stdout":"A seed for a cluster algebra of rank 6 of type ['A', [3, 3], 1] with principal coefficients\n"}︡
︠5726c3d9-3223-455e-8e82-e9f42733efd8os︠
QuiverMutationType?
︡5ac66d43-1c8f-4651-93ae-7cfed4b16ee0︡{"code":{"source":"File: /projects/sage/sage-6.7/src/sage/misc/lazy_import.pyx\nSignature : QuiverMutationType(*args)\nDocstring :\n*Quiver mutation types* can be seen as a slight generalization of\n*generalized Cartan types*.\n\nBackground on generalized Cartan types can be found at\n\nhttp://en.wikipedia.org/wiki/Generalized_Cartan_matrix\n\nFor the compendium on the cluster algebra and quiver package in Sage\nsee\n\nhttp://arxiv.org/abs/1102.4844\n\nA B-matrix is a skew-symmetrizable ( n x n )-matrix M. I.e.,\nthere exists an invertible diagonal matrix D such that DM is skew-\nsymmetric.  M can be encoded as a *quiver* by having a directed edge\nfrom vertex i to vertex j with label (a,b) if a = M_{i,j} > 0 and b =\nM_{j,i} < 0.  We consider quivers up to *mutation equivalence*.\n\nTo a quiver mutation type we can associate a *generalized Cartan type*\nby sending M to the generalized Cartan matrix C(M) obtained by\nreplacing all positive entries by their negatives and adding 2's on\nthe main diagonal.\n\n\"QuiverMutationType\" constructs a quiver mutation type object. For\nmore detail on the possible different types, please see the\ncompendium.\n\nINPUT:\n\nThe input consists either of a quiver mutation type, or of a \"letter\"\n(a string), a \"rank\" (one integer or a list/tuple of integers), and an\noptional \"twist\" (an integer or a list of integers).  There are\nseveral different naming conventions for quiver mutation types.\n\n* Finite type -- \"letter\" is a Dynkin type (A-G), and \"rank\" is the\n  rank.\n\n* Affine type -- there is more than one convention for naming affine\n  types.\n\n  * Kac's notation: \"letter\" is a Dynkin type, \"rank\" is the rank\n    of the associated finite Dynkin diagram, and \"twist\" is the\n    twist, which could be 1, 2, or 3.  In the special case of\n    affine type A, there is more than one quiver mutation type\n    associated to the Cartan type.  In this case only, \"rank\" is a\n    pair of integers (i,j), giving the number of edges pointing\n    clockwise and the number of edges pointing counter-clockwise.\n    The total number of vertices is given by i+j in this case.\n\n  * Naive notation: \"letter\" is one of 'BB', 'BC', 'BD', 'CC',\n    'CD'.  The name specifies the two ends of the diagram, which\n    are joined by a path.  The total number of vertices is given by\n    \"rank +1\" (to match the indexing people expect because these\n    are affine types).  In general, \"rank\" must be large enough for\n    the picture to make sense, but we accept \"letter\" is \"BC\" and\n    \"rank=1\".\n\n  * Macdonald notation: for the dual of an untwisted affine type\n    (such as ['C', 6,1]), we accept a twist of -1 (i.e.,\n    ['C',6,-1]).\n\n* Elliptic type -- \"letter\" is a Dynkin type, \"rank\" is the rank of\n  the finite Dynkin diagram, and \"twist\" is a tuple of two integers.\n  We follow Saito's notation.\n\n* Other shapes:\n\n  * Rank 2: \"letter\" is 'R2', and \"rank\" is a pair of integers\n    specifying the label on the unique edge.\n\n  * Triangle: \"letter\" is \"TR\", and \"rank\" is the number of\n    vertices along a side.\n\n  * T: This defines a quiver shaped like a T.  \"letter\" is 'T',\n    and the \"rank\" is a triple, whose entries specify the number of\n    vertices along each path from the branch point (counting the\n    branch point).\n\n  * Grassmannian: This defines the cluster algebra (without\n    coefficients) corresponding to the cluster algebra with\n    coefficients which is the co-ordinate ring of a Grassmannian.\n    \"letter\" is 'GR'.  \"rank\" is a pair of integers (k, n) with 'k'\n    < 'n' specifying the Grassmannian of k-planes in n-space.  This\n    defines a quiver given by a (k-1) x (n-k-1) grid where each\n    square is cyclically oriented.\n\n  * Exceptional mutation finite quivers: The two exceptional\n    mutation finite quivers, found by Derksen-Owen, have \"letter\"\n    as 'X' and \"rank\" 6 or 7, equal to the number of vertices.\n\n  * AE, BE, CE, DE: Quivers are built of one end which looks like\n    type (affine A), B, C, or D, and the other end which looks like\n    type E (i.e., it consists of two antennae, one of length one,\n    and one of length two).  \"letter\" is 'AE', 'BE', 'CE', or 'DE',\n    and \"rank\" is the total number of vertices.  Note that 'AE' is\n    of a slightly different form and requires \"rank\" to be a pair\n    of integers (i,j) just as in the case of affine type A. See\n    Exercise 4.3 in Kac's book Infinite Dimensional Lie Algebras\n    for more details.\n\n  * Infinite type E: It is also possible to obtain infinite-type\n    E quivers by specifying \"letter\" as 'E' and \"rank\" as the\n    number of vertices.\n\nREFERENCES:\n\n* A good reference for finite and affine Dynkin diagrams, including\n  Kac's notation, is the http://en.wikipedia.org/wiki/Dynkin_diagram.\n\n* A good reference for the skew-symmetrizable elliptic diagrams is\n  \"Cluster algebras of finite mutation type via unfolding\" by A.\n  Felikson, M. Shapiro, and P. Tumarkin,\n  http://arxiv.org/abs/1006.4276v4.\n\nEXAMPLES:\n\nFinite types:\n\nsage: QuiverMutationType('A',1)\n['A', 1]\nsage: QuiverMutationType('A',5)\n['A', 5]\n\nsage: QuiverMutationType('B',2)\n['B', 2]\nsage: QuiverMutationType('B',5)\n['B', 5]\n\nsage: QuiverMutationType('C',2)\n['B', 2]\nsage: QuiverMutationType('C',5)\n['C', 5]\n\nsage: QuiverMutationType('D',2)\n[ ['A', 1], ['A', 1] ]\nsage: QuiverMutationType('D',3)\n['A', 3]\nsage: QuiverMutationType('D',4)\n['D', 4]\n\nsage: QuiverMutationType('E',6)\n['E', 6]\n\nsage: QuiverMutationType('G',2)\n['G', 2]\n\nsage: QuiverMutationType('A',(1,0),1)\n['A', 1]\n\nsage: QuiverMutationType('A',(2,0),1)\n[ ['A', 1], ['A', 1] ]\n\nsage: QuiverMutationType('A',(7,0),1)\n['D', 7]\n\nAffine types:\n\nsage: QuiverMutationType('A',(1,1),1)\n['A', [1, 1], 1]\nsage: QuiverMutationType('A',(2,4),1)\n['A', [2, 4], 1]\n\nsage: QuiverMutationType('BB',2,1)\n['BB', 2, 1]\nsage: QuiverMutationType('BB',4,1)\n['BB', 4, 1]\n\nsage: QuiverMutationType('CC',2,1)\n['CC', 2, 1]\nsage: QuiverMutationType('CC',4,1)\n['CC', 4, 1]\n\nsage: QuiverMutationType('BC',1,1)\n['BC', 1, 1]\nsage: QuiverMutationType('BC',5,1)\n['BC', 5, 1]\n\nsage: QuiverMutationType('BD',3,1)\n['BD', 3, 1]\nsage: QuiverMutationType('BD',5,1)\n['BD', 5, 1]\n\nsage: QuiverMutationType('CD',3,1)\n['CD', 3, 1]\nsage: QuiverMutationType('CD',5,1)\n['CD', 5, 1]\n\nsage: QuiverMutationType('D',4,1)\n['D', 4, 1]\nsage: QuiverMutationType('D',6,1)\n['D', 6, 1]\n\nsage: QuiverMutationType('E',6,1)\n['E', 6, 1]\nsage: QuiverMutationType('E',7,1)\n['E', 7, 1]\nsage: QuiverMutationType('E',8,1)\n['E', 8, 1]\n\nsage: QuiverMutationType('F',4,1)\n['F', 4, 1]\nsage: QuiverMutationType('F',4,-1)\n['F', 4, -1]\n\nsage: QuiverMutationType('G',2,1)\n['G', 2, 1]\nsage: QuiverMutationType('G',2,-1)\n['G', 2, -1]\nsage: QuiverMutationType('A',3,2) == QuiverMutationType('D',3,2)\nTrue\n\nAffine types using Kac's Notation:\n\nsage: QuiverMutationType('A',1,1)\n['A', [1, 1], 1]\nsage: QuiverMutationType('B',5,1)\n['BD', 5, 1]\nsage: QuiverMutationType('C',5,1)\n['CC', 5, 1]\nsage: QuiverMutationType('A',2,2)\n['BC', 1, 1]\nsage: QuiverMutationType('A',7,2)\n['CD', 4, 1]\nsage: QuiverMutationType('A',8,2)\n['BC', 4, 1]\nsage: QuiverMutationType('D',6,2)\n['BB', 5, 1]\nsage: QuiverMutationType('E',6,2)\n['F', 4, -1]\nsage: QuiverMutationType('D',4,3)\n['G', 2, -1]\n\nElliptic types:\n\nsage: QuiverMutationType('E',6,[1,1])\n['E', 6, [1, 1]]\nsage: QuiverMutationType('F',4,[2,1])\n['F', 4, [1, 2]]\nsage: QuiverMutationType('G',2,[3,3])\n['G', 2, [3, 3]]\n\nMutation finite types:\n\nrank 2 cases:\n\n   sage: QuiverMutationType('R2',(1,1))\n   ['A', 2]\n   sage: QuiverMutationType('R2',(1,2))\n   ['B', 2]\n   sage: QuiverMutationType('R2',(1,3))\n   ['G', 2]\n   sage: QuiverMutationType('R2',(1,4))\n   ['BC', 1, 1]\n   sage: QuiverMutationType('R2',(1,5))\n   ['R2', [1, 5]]\n   sage: QuiverMutationType('R2',(2,2))\n   ['A', [1, 1], 1]\n   sage: QuiverMutationType('R2',(3,5))\n   ['R2', [3, 5]]\n\nExceptional Derksen-Owen quivers:\n\n   sage: QuiverMutationType('X',6)\n   ['X', 6]\n\n(Mainly) mutation infinite types:\n\nInfinite type E:\n\n   sage: QuiverMutationType('E',9)\n   ['E', 8, 1]\n   sage: QuiverMutationType('E',10)\n   ['E', 10]\n   sage: QuiverMutationType('E',12)\n   ['E', 12]\n\n   sage: QuiverMutationType('AE',(2,3))\n   ['AE', [2, 3]]\n   sage: QuiverMutationType('BE',5)\n   ['BE', 5]\n   sage: QuiverMutationType('CE',5)\n   ['CE', 5]\n   sage: QuiverMutationType('DE',6)\n   ['DE', 6]\n\nGrassmannian types:\n\n   sage: QuiverMutationType('GR',(2,4))\n   ['A', 1]\n   sage: QuiverMutationType('GR',(2,6))\n   ['A', 3]\n   sage: QuiverMutationType('GR',(3,6))\n   ['D', 4]\n   sage: QuiverMutationType('GR',(3,7))\n   ['E', 6]\n   sage: QuiverMutationType('GR',(3,8))\n   ['E', 8]\n   sage: QuiverMutationType('GR',(3,10))\n   ['GR', [3, 10]]\n\nTriangular types:\n\n   sage: QuiverMutationType('TR',2)\n   ['A', 3]\n   sage: QuiverMutationType('TR',3)\n   ['D', 6]\n   sage: QuiverMutationType('TR',4)\n   ['E', 8, [1, 1]]\n   sage: QuiverMutationType('TR',5)\n   ['TR', 5]\n\nT types:\n\n   sage: QuiverMutationType('T',(1,1,1))\n   ['A', 1]\n   sage: QuiverMutationType('T',(1,1,4))\n   ['A', 4]\n   sage: QuiverMutationType('T',(1,4,4))\n   ['A', 7]\n   sage: QuiverMutationType('T',(2,2,2))\n   ['D', 4]\n   sage: QuiverMutationType('T',(2,2,4))\n   ['D', 6]\n   sage: QuiverMutationType('T',(2,3,3))\n   ['E', 6]\n   sage: QuiverMutationType('T',(2,3,4))\n   ['E', 7]\n   sage: QuiverMutationType('T',(2,3,5))\n   ['E', 8]\n   sage: QuiverMutationType('T',(2,3,6))\n   ['E', 8, 1]\n   sage: QuiverMutationType('T',(2,3,7))\n   ['E', 10]\n   sage: QuiverMutationType('T',(3,3,3))\n   ['E', 6, 1]\n   sage: QuiverMutationType('T',(3,3,4))\n   ['T', [3, 3, 4]]\n\nReducible types:\n\nsage: QuiverMutationType(['A',3],['B',4])\n[ ['A', 3], ['B', 4] ]","mode":"text/x-rst","lineno":-1,"filename":null}}︡
︠79509a50-37e3-42c2-9513-9bf617d40c75os︠
Gr = ClusterSeed(['GR',[4,9]]); Gr; Gr.show()
︡40f8690e-1f7f-407e-915d-efd6a92f8e3a︡{"stdout":"A seed for a cluster algebra of rank 12 of type ['GR', [4, 9]]\n"}︡{"once":false,"file":{"show":true,"uuid":"56dc58b7-363f-46ec-9252-f4413676ba37","filename":"/projects/02aac756-d7ee-4d37-9546-ef8d58152220/.sage/temp/compute2-us/30002/tmp_s6QkA7.svg"}}︡{"html":"<div align='center'></div>"}︡
︠c5692b26-5e80-4fd2-b0a1-01f852ce3138os︠
Gr.is_mutation_finite()
︡dac8c0e8-99a4-4994-82ce-93aadd28ee51︡{"stdout":"False\n"}︡
︠386df946-1945-4b0a-a812-3d9f6d8c50bcos︠
Gr2 = ClusterSeed(['GR',[4,8]]); Gr2;
︡f5e6431b-7f3d-4c98-944c-3d9a88ed2db6︡{"stdout":"A seed for a cluster algebra of rank 9 of type ['E', 7, [1, 1]]\n"}︡
︠ec8a603b-75b7-455c-b9ab-b3fdf1921e6eos︠
Gr2.is_mutation_finite()
︡2c77ac37-58b8-4ce0-b6d7-7db58dcc42e8︡{"stdout":"True"}︡{"stdout":"\n"}︡
︠300321c8-7375-4cc0-959a-a618f133ee39os︠
Tr = ClusterSeed(['TR',5]); Tr; Tr.show()
︡5999d7bc-7a63-495f-833f-3c0044827632︡{"stdout":"A seed for a cluster algebra of rank 15 of type ['TR', 5]\n"}︡{"once":false,"file":{"show":true,"uuid":"d3be5d18-ef18-4c80-8f25-ae976fc597f2","filename":"/projects/02aac756-d7ee-4d37-9546-ef8d58152220/.sage/temp/compute2-us/30002/tmp_9BBaLo.svg"}}︡{"html":"<div align='center'></div>"}︡
︠7dfd0449-f987-475f-b55e-9c49a5226ea2os︠
NSL = ClusterSeed(['F',4,1]); NSL; NSL.show()
︡77fa0764-e9fb-4851-b9ed-372c32afee9e︡{"stdout":"A seed for a cluster algebra of rank 5 of type ['F', 4, 1]\n"}︡{"once":false,"file":{"show":true,"uuid":"951328d1-e938-4424-9b6c-2c4b46006dc7","filename":"/projects/02aac756-d7ee-4d37-9546-ef8d58152220/.sage/temp/compute2-us/30002/tmp_I8sPWx.svg"}}︡{"html":"<div align='center'></div>"}︡
︠2bcfb7f6-517b-4d04-9ab5-618e35120416os︠
NSL2 = ClusterSeed(['F',4,-1]); NSL2; NSL2.show()
︡619160f6-3141-45f6-9e33-1488f6d78d4a︡{"stdout":"A seed for a cluster algebra of rank 5 of type ['F', 4, -1]\n"}︡{"once":false,"file":{"show":true,"uuid":"de4841d6-73f8-4a6d-bd93-25ce4c8b9ab3","filename":"/projects/02aac756-d7ee-4d37-9546-ef8d58152220/.sage/temp/compute2-us/30002/tmp_owiQXz.svg"}}︡{"html":"<div align='center'></div>"}︡
︠636b09a4-46c5-4209-9d21-b2c2fbcb13b5os︠
BB = NSL.b_matrix_class(); len(BB);
︡820e0b15-da54-47d9-89c5-0dc7b99caafb︡{"stdout":"60"}︡{"stdout":"\n"}︡
︠f5d9ea5a-3b66-4908-9c50-41557ab744a2os︠
BB
︡2cbda72d-4c9c-4a29-97b8-b6b4dc1082a0︡{"stdout":"[[ 0  0  0  0  1]\n[ 0  0  0  1  0]\n[ 0  0  0  1  1]\n[ 0 -1 -2  0  0]\n[-1  0 -1  0  0], [ 0  0  0  0  1]\n[ 0  0  1  0  1]\n[ 0 -2  0  1  0]\n[ 0  0 -1  0  0]\n[-1 -1  0  0  0], [ 0  0  0  0  1]\n[ 0  0  2  1  0]\n[ 0 -1  0  0  1]\n[ 0 -1  0  0  0]\n[-1  0 -1  0  0], [ 0  0  1  0  0]\n[ 0  0  0  0  1]\n[-1  0  0  2  0]\n[ 0  0 -1  0 -1]\n[ 0 -1  0  1  0], [ 0  0  0  0  1]\n[ 0  0  1  1  0]\n[ 0 -1  0  0  0]\n[ 0 -1  0  0  1]\n[-1  0  0 -2  0], [ 0  0  0  1  0]\n[ 0  0  0  1  1]\n[ 0  0  0  0 -1]\n[-1 -2  0  0  0]\n[ 0 -1  1  0  0], [ 0  0  0  1 -2]\n[ 0  0  1  0  1]\n[ 0 -1  0  0  0]\n[-1  0  0  0  0]\n[ 1 -1  0  0  0], [ 0  0  0  0  1]\n[ 0  0  1 -1  1]\n[ 0 -2  0  1  0]\n[ 0  2 -1  0  0]\n[-1 -1  0  0  0], [ 0  0  0  0  1]\n[ 0  0  1  2  0]\n[ 0 -1  0  0  0]\n[ 0 -1  0  0 -1]\n[-1  0  0  1  0], [ 0  1  0  0  1]\n[-2  0  1  0  0]\n[ 0 -1  0  0  0]\n[ 0  0  0  0 -1]\n[-1  0  0  1  0], [ 0  1  0  0  0]\n[-1  0  0  0 -2]\n[ 0  0  0 -1  1]\n[ 0  0  1  0 -1]\n[ 0  1 -1  1  0], [ 0  2  0  1  0]\n[-1  0  0  0  1]\n[ 0  0  0  0 -1]\n[-1  0  0  0  0]\n[ 0 -1  1  0  0], [ 0  0  0  1  0]\n[ 0  0  1  0  1]\n[ 0 -1  0  0  0]\n[-1  0  0  0  2]\n[ 0 -1  0 -1  0], [ 0  1  0  0  0]\n[-1  0  0  0  2]\n[ 0  0  0 -1  1]\n[ 0  0  1  0 -1]\n[ 0 -1 -1  1  0], [ 0  0  0  0  1]\n[ 0  0  1 -2  0]\n[ 0 -1  0  2  0]\n[ 0  1 -1  0 -1]\n[-1  0  0  1  0], [ 0  0  0  1  2]\n[ 0  0  1  0  1]\n[ 0 -1  0  0  0]\n[-1  0  0  0  0]\n[-1 -1  0  0  0], [ 0  0  0  1  0]\n[ 0  0  0 -1  1]\n[ 0  0  0  0 -1]\n[-1  2  0  0 -2]\n[ 0 -1  1  1  0], [ 0  0  0  1  0]\n[ 0  0  0  0  1]\n[ 0  0  0  1 -1]\n[-1  0 -2  0  0]\n[ 0 -1  1  0  0], [ 0  0  0  0  1]\n[ 0  0  1 -2  2]\n[ 0 -1  0  0  0]\n[ 0  1  0  0 -1]\n[-1 -1  0  1  0], [ 0  0  0  0  1]\n[ 0  0  0  1  0]\n[ 0  0  0 -1  1]\n[ 0 -1  2  0  0]\n[-1  0 -1  0  0], [ 0  2  0  1 -2]\n[-1  0  1  0  1]\n[ 0 -1  0  0  0]\n[-1  0  0  0  2]\n[ 1 -1  0 -1  0], [ 0  0  0  0  1]\n[ 0  0  0  1  0]\n[ 0  0  0 -1  1]\n[ 0 -1  2  0 -2]\n[-1  0 -1  1  0], [ 0 -1  0  0  1]\n[ 2  0  1  0 -2]\n[ 0 -1  0  0  0]\n[ 0  0  0  0 -1]\n[-1  1  0  1  0], [ 0  0  0  1 -2]\n[ 0  0  1  0  1]\n[ 0 -1  0  0  0]\n[-1  0  0  0  2]\n[ 1 -1  0 -1  0], [ 0  0  0  0  1]\n[ 0  0  1 -2  0]\n[ 0 -1  0  0  0]\n[ 0  1  0  0 -1]\n[-1  0  0  1  0], [ 0  0  0  0  1]\n[ 0  0  1 -2  2]\n[ 0 -1  0  2  0]\n[ 0  1 -1  0 -1]\n[-1 -1  0  1  0], [ 0  1  0 -1  1]\n[-2  0  0  1  0]\n[ 0  0  0  0 -1]\n[ 2 -1  0  0  0]\n[-1  0  1  0  0], [ 0  1  0  0 -2]\n[-1  0  0  0  0]\n[ 0  0  0 -1  1]\n[ 0  0  1  0 -1]\n[ 1  0 -1  1  0], [ 0  1  0  0  2]\n[-1  0  0  0  0]\n[ 0  0  0 -1  1]\n[ 0  0  1  0 -1]\n[-1  0 -1  1  0], [ 0  0  0  1  0]\n[ 0  0  0  0  1]\n[ 0  0  0  1 -1]\n[-1  0 -2  0  2]\n[ 0 -1  1 -1  0], [ 0  1  0  0 -2]\n[-1  0  0  0  2]\n[ 0  0  0 -1  1]\n[ 0  0  1  0 -1]\n[ 1 -1 -1  1  0], [ 0  0  0  0  1]\n[ 0  0 -2  1  0]\n[ 0  1  0 -1  1]\n[ 0 -1  2  0 -2]\n[-1  0 -1  1  0], [ 0  2  0  1 -2]\n[-1  0  1  0  1]\n[ 0 -1  0  0  0]\n[-1  0  0  0  0]\n[ 1 -1  0  0  0], [ 0  0  0  1  0]\n[ 0  0  0 -1  1]\n[ 0  0  0  0 -1]\n[-1  2  0  0  0]\n[ 0 -1  1  0  0], [ 0  1  0 -1  1]\n[-2  0  0  1  0]\n[ 0  0  0  0 -1]\n[ 2 -1  0  0 -2]\n[-1  0  1  1  0], [ 0  0  0  1 -2]\n[ 0  0  1 -1  1]\n[ 0 -1  0  1  0]\n[-1  2 -2  0  0]\n[ 1 -1  0  0  0], [ 0  0  0  0  1]\n[ 0  0  0 -1  1]\n[ 0  0  0  1 -2]\n[ 0  2 -1  0  0]\n[-1 -1  1  0  0], [ 0  0  0  0  1]\n[ 0  0 -1  0  1]\n[ 0  2  0  1 -2]\n[ 0  0 -1  0  0]\n[-1 -1  1  0  0], [ 0  0  0  0  1]\n[ 0  0  1  1 -1]\n[ 0 -1  0  0  0]\n[ 0 -1  0  0  1]\n[-1  2  0 -2  0], [ 0  1  0  0 -2]\n[-1  0  0  2  0]\n[ 0  0  0  1 -1]\n[ 0 -1 -1  0  1]\n[ 1  0  1 -1  0], [ 0  0  0  0  1]\n[ 0  0  1 -2  0]\n[ 0 -1  0  0  2]\n[ 0  1  0  0 -1]\n[-1  0 -1  1  0], [ 0  0  0  0  1]\n[ 0  0 -1  0  1]\n[ 0  2  0  1 -2]\n[ 0  0 -1  0  2]\n[-1 -1  1 -1  0], [ 0  0 -1  0  1]\n[ 0  0  0 -1  1]\n[ 2  0  0  1 -2]\n[ 0  2 -1  0  0]\n[-1 -1  1  0  0], [ 0  0  0  1 -2]\n[ 0  0  1 -1  1]\n[ 0 -1  0  0  0]\n[-1  2  0  0  0]\n[ 1 -1  0  0  0], [ 0 -1  0  0  1]\n[ 2  0  0  1 -2]\n[ 0  0  0  1 -1]\n[ 0 -1 -2  0  2]\n[-1  1  1 -1  0], [ 0 -2  0  0  1]\n[ 1  0  1  1 -1]\n[ 0 -1  0  0  0]\n[ 0 -1  0  0  1]\n[-1  2  0 -2  0], [ 0 -1  0  0  1]\n[ 2  0  0  1 -2]\n[ 0  0  0  0 -1]\n[ 0 -1  0  0  2]\n[-1  1  1 -1  0], [ 0  1  0  0 -2]\n[-1  0  0 -2  2]\n[ 0  0  0 -1  1]\n[ 0  1  1  0 -1]\n[ 1 -1 -1  1  0], [ 0  0  0  0  1]\n[ 0  0  0  1 -2]\n[ 0  0  0  1 -1]\n[ 0 -1 -2  0  2]\n[-1  1  1 -1  0], [ 0  0  0 -1  1]\n[ 0  0  0  1 -2]\n[ 0  0  0  0 -1]\n[ 2 -1  0  0  0]\n[-1  1  1  0  0], [ 0  0 -2  1  0]\n[ 0  0  0 -1  1]\n[ 1  0  0 -1  1]\n[-1  2  2  0 -2]\n[ 0 -1 -1  1  0], [ 0  0 -1  0  1]\n[ 0  0  1 -2  0]\n[ 2 -1  0  0  0]\n[ 0  1  0  0 -1]\n[-1  0  0  1  0], [ 0  2  1 -2 -2]\n[-1  0  0  1  1]\n[-1  0  0  0  2]\n[ 1 -1  0  0  0]\n[ 1 -1 -1  0  0], [ 0  1  0  2 -2]\n[-1  0  0  0  2]\n[ 0  0  0  1 -1]\n[-1  0 -1  0  1]\n[ 1 -1  1 -1  0], [ 0  1  0 -1  1]\n[-2  0  0  1  0]\n[ 0  0  0  1 -1]\n[ 2 -1 -2  0  0]\n[-1  0  1  0  0], [ 0 -1  0  0  1]\n[ 2  0  1 -2  0]\n[ 0 -1  0  2  0]\n[ 0  1 -1  0 -1]\n[-1  0  0  1  0], [ 0  0  0  1  0]\n[ 0  0  1 -1  1]\n[ 0 -1  0  0  1]\n[-1  2  0  0 -2]\n[ 0 -1 -1  1  0], [ 0 -1  0  1  1]\n[ 2  0  1  0 -2]\n[ 0 -1  0  0  0]\n[-1  0  0  0  1]\n[-1  1  0 -1  0], [ 0  0  0  1  0]\n[ 0  0 -2  1  1]\n[ 0  2  0 -1 -1]\n[-1 -2  2  0  0]\n[ 0 -1  1  0  0], [ 0  1  0 -2  1]\n[-2  0  1  2  0]\n[ 0 -1  0  0  0]\n[ 2 -1  0  0 -1]\n[-1  0  0  1  0]]"}︡{"stdout":"\n"}︡
︠0be7e5ee-99bb-490e-91c8-6607f43ae12dos︠
BB2 = NSL2.b_matrix_class(); len(BB2)
︡68a3998b-4139-45d0-8f85-5aa91f67b44b︡{"stdout":"60"}︡{"stdout":"\n"}︡
︠5576258b-a6a2-4ecc-aa7a-e1977e9ca3d7os︠
BB2 = NSL2.b_matrix_class(up_to_equivalence=False); len(BB2)
︡dbeebf6d-a9f9-440d-aa71-fab24b5c8820︡{"stdout":"720"}︡{"stdout":"\n"}︡
︠6bffdb6e-85b3-4364-9446-f0dc929bd4c7os︠
for Mat in BB:
    if Mat in BB2:
        print("Found Matrix")
print("Done")
︡9b469510-0731-4ecc-952d-692887701fd8︡{"stdout":"Done\n"}︡
︠685da55c-88bf-4426-ad5d-bca0cbde043bos︠
NSL.interact()
︡a6bda854-07bc-4c18-bc19-ee90aa591c9a︡{"stdout":"'The interactive mode only runs in the Sage notebook.'\n"}︡
︠96f572cc-66c0-4a47-9ba0-cc16722266dfos︠
EE7 = ClusterSeed(['E',7]); EE7.show()
︡05921f3b-e6cd-4fa5-b37c-92a1c64b4366︡{"once":false,"file":{"show":true,"uuid":"e85c9d08-ee64-4b3e-b165-b338b1b6807a","filename":"/projects/02aac756-d7ee-4d37-9546-ef8d58152220/.sage/temp/compute2-us/30002/tmp_ZUNFUw.svg"}}︡{"html":"<div align='center'></div>"}︡
︠4d32b222-094b-41a5-8de6-d790283a2ffbos︠
VC = EE7.variable_class(); len(VC)
︡164c825e-d31a-46f1-a6ae-14a23ce84f09︡{"stdout":"70"}︡{"stdout":"\n"}︡
︠e7b69e06-63f9-457b-935b-b0507384d615os︠
VC[35]
︡7e3bad72-7f7a-45d3-a9de-9e4a375d922c︡{"stdout":"(x1*x3^2*x5*x6 + x0*x2^2*x4 + x0*x2*x3*x5 + x1*x3*x6 + x0*x2 + x2*x4 + x3*x5 + 1)/(x1*x2*x3*x4)\n"}︡
︠7d490760-0d30-46fc-b858-9becb24d2ea1os︠
for i in range(len(VC)):
    if max(VC[i].denominator().exponents()[0]) > 1:
        print(i)
︡233d2a9c-3aa9-45ca-9e56-5e1aa93998e5︡{"stdout":"1\n2\n3\n4\n6\n19\n21\n25\n26\n28\n29\n30\n31\n32\n33\n36\n37\n38\n39\n40\n43\n44\n47\n48\n63\n64\n65\n66\n67\n"}︡
︠49a3cd00-5b29-4a49-8cbc-b5b06df524f0os︠
VC[34]
︡912b48a2-a6a6-4b9a-ad82-041027730cdc︡{"stdout":"(x1^2*x3^2*x5*x6 + x1*x3^2*x5*x6 + x0*x2^2*x4 + x0*x2*x3*x5 + x1^2*x3*x6 + x1*x2*x4 + x1*x3*x5 + x1*x3*x6 + x0*x2 + x2*x4 + x3*x5 + x1 + 1)/(x0*x1*x2*x3*x4)\n"}︡
︠e147a09f-2a02-49d7-958c-75bff0ab4e94os︠
X = ClusterSeed(['X',6]); X; X.show()
︡7a2453b3-e00d-4283-a02e-ce5da1e6b36c︡{"stdout":"A seed for a cluster algebra of rank 6 of type ['X', 6]\n"}︡{"once":false,"file":{"show":true,"uuid":"7bb06a6d-d018-4ee4-9b2d-757fff531378","filename":"/projects/02aac756-d7ee-4d37-9546-ef8d58152220/.sage/temp/compute2-us/30002/tmp_YjC62M.svg"}}︡{"html":"<div align='center'></div>"}︡
︠4f0117eb-b8db-47d5-a5b8-020a455ddb5dos︠
S = ClusterSeed(['X',7]); S; S.show()
︡7b6a5065-037f-4a82-ab60-51cbcbfc9f30︡{"stdout":"A seed for a cluster algebra of rank 7 of type ['X', 7]\n"}︡{"once":false,"file":{"show":true,"uuid":"6c4ba077-b47b-4ca1-96d1-17a4cbb579b9","filename":"/projects/02aac756-d7ee-4d37-9546-ef8d58152220/.sage/temp/compute2-us/30002/tmp_99aFrT.svg"}}︡{"html":"<div align='center'></div>"}︡
︠c379c5c6-0ddd-4329-a2f8-53f89215fed1os︠
X.is_finite()
︡4d744bd4-8c8c-4b03-aedd-395d4da28a53︡{"stdout":"False\n"}︡
︠fab15184-c80d-4507-8210-859425b7872cos︠
X.is_mutation_finite()
︡f76b5290-07f7-4780-9390-d00ea0ca3d07︡{"stdout":"True"}︡{"stdout":"\n"}︡
︠961a96dc-a146-42c1-8000-678dd3862234os︠
V = ClusterSeed(['F',4,1]); V; V.show()
︡2ae6f480-f3bf-4e85-9d20-3538014c7ab9︡{"stdout":"A seed for a cluster algebra of rank 5 of type ['F', 4, 1]\n"}︡{"once":false,"file":{"show":true,"uuid":"9f4c5670-1017-440b-9809-7aa2abcd27f4","filename":"/projects/02aac756-d7ee-4d37-9546-ef8d58152220/.sage/temp/compute2-us/30002/tmp_zoiFkn.svg"}}︡{"html":"<div align='center'></div>"}︡
︠93411224-52fb-49c9-a2a6-367a6efc39cdos︠
VMC = V.b_matrix_class(); len(VMC); VMC
︡9191453a-3715-45b9-859e-22ca4bf00364︡{"stdout":"60"}︡{"stdout":"\n[[ 0  0  0  0  1]\n[ 0  0  0  1  0]\n[ 0  0  0  1  1]\n[ 0 -1 -2  0  0]\n[-1  0 -1  0  0], [ 0  0  0  0  1]\n[ 0  0  1  0  1]\n[ 0 -2  0  1  0]\n[ 0  0 -1  0  0]\n[-1 -1  0  0  0], [ 0  0  0  0  1]\n[ 0  0  2  1  0]\n[ 0 -1  0  0  1]\n[ 0 -1  0  0  0]\n[-1  0 -1  0  0], [ 0  0  1  0  0]\n[ 0  0  0  0  1]\n[-1  0  0  2  0]\n[ 0  0 -1  0 -1]\n[ 0 -1  0  1  0], [ 0  0  0  0  1]\n[ 0  0  1  1  0]\n[ 0 -1  0  0  0]\n[ 0 -1  0  0  1]\n[-1  0  0 -2  0], [ 0  0  0  1  0]\n[ 0  0  0  1  1]\n[ 0  0  0  0 -1]\n[-1 -2  0  0  0]\n[ 0 -1  1  0  0], [ 0  0  0  1 -2]\n[ 0  0  1  0  1]\n[ 0 -1  0  0  0]\n[-1  0  0  0  0]\n[ 1 -1  0  0  0], [ 0  0  0  0  1]\n[ 0  0  1 -1  1]\n[ 0 -2  0  1  0]\n[ 0  2 -1  0  0]\n[-1 -1  0  0  0], [ 0  0  0  0  1]\n[ 0  0  1  2  0]\n[ 0 -1  0  0  0]\n[ 0 -1  0  0 -1]\n[-1  0  0  1  0], [ 0  1  0  0  1]\n[-2  0  1  0  0]\n[ 0 -1  0  0  0]\n[ 0  0  0  0 -1]\n[-1  0  0  1  0], [ 0  1  0  0  0]\n[-1  0  0  0 -2]\n[ 0  0  0 -1  1]\n[ 0  0  1  0 -1]\n[ 0  1 -1  1  0], [ 0  2  0  1  0]\n[-1  0  0  0  1]\n[ 0  0  0  0 -1]\n[-1  0  0  0  0]\n[ 0 -1  1  0  0], [ 0  0  0  1  0]\n[ 0  0  1  0  1]\n[ 0 -1  0  0  0]\n[-1  0  0  0  2]\n[ 0 -1  0 -1  0], [ 0  1  0  0  0]\n[-1  0  0  0  2]\n[ 0  0  0 -1  1]\n[ 0  0  1  0 -1]\n[ 0 -1 -1  1  0], [ 0  0  0  0  1]\n[ 0  0  1 -2  0]\n[ 0 -1  0  2  0]\n[ 0  1 -1  0 -1]\n[-1  0  0  1  0], [ 0  0  0  1  2]\n[ 0  0  1  0  1]\n[ 0 -1  0  0  0]\n[-1  0  0  0  0]\n[-1 -1  0  0  0], [ 0  0  0  1  0]\n[ 0  0  0 -1  1]\n[ 0  0  0  0 -1]\n[-1  2  0  0 -2]\n[ 0 -1  1  1  0], [ 0  0  0  1  0]\n[ 0  0  0  0  1]\n[ 0  0  0  1 -1]\n[-1  0 -2  0  0]\n[ 0 -1  1  0  0], [ 0  0  0  0  1]\n[ 0  0  1 -2  2]\n[ 0 -1  0  0  0]\n[ 0  1  0  0 -1]\n[-1 -1  0  1  0], [ 0  0  0  0  1]\n[ 0  0  0  1  0]\n[ 0  0  0 -1  1]\n[ 0 -1  2  0  0]\n[-1  0 -1  0  0], [ 0  2  0  1 -2]\n[-1  0  1  0  1]\n[ 0 -1  0  0  0]\n[-1  0  0  0  2]\n[ 1 -1  0 -1  0], [ 0  0  0  0  1]\n[ 0  0  0  1  0]\n[ 0  0  0 -1  1]\n[ 0 -1  2  0 -2]\n[-1  0 -1  1  0], [ 0 -1  0  0  1]\n[ 2  0  1  0 -2]\n[ 0 -1  0  0  0]\n[ 0  0  0  0 -1]\n[-1  1  0  1  0], [ 0  0  0  1 -2]\n[ 0  0  1  0  1]\n[ 0 -1  0  0  0]\n[-1  0  0  0  2]\n[ 1 -1  0 -1  0], [ 0  0  0  0  1]\n[ 0  0  1 -2  0]\n[ 0 -1  0  0  0]\n[ 0  1  0  0 -1]\n[-1  0  0  1  0], [ 0  0  0  0  1]\n[ 0  0  1 -2  2]\n[ 0 -1  0  2  0]\n[ 0  1 -1  0 -1]\n[-1 -1  0  1  0], [ 0  1  0 -1  1]\n[-2  0  0  1  0]\n[ 0  0  0  0 -1]\n[ 2 -1  0  0  0]\n[-1  0  1  0  0], [ 0  1  0  0 -2]\n[-1  0  0  0  0]\n[ 0  0  0 -1  1]\n[ 0  0  1  0 -1]\n[ 1  0 -1  1  0], [ 0  1  0  0  2]\n[-1  0  0  0  0]\n[ 0  0  0 -1  1]\n[ 0  0  1  0 -1]\n[-1  0 -1  1  0], [ 0  0  0  1  0]\n[ 0  0  0  0  1]\n[ 0  0  0  1 -1]\n[-1  0 -2  0  2]\n[ 0 -1  1 -1  0], [ 0  1  0  0 -2]\n[-1  0  0  0  2]\n[ 0  0  0 -1  1]\n[ 0  0  1  0 -1]\n[ 1 -1 -1  1  0], [ 0  0  0  0  1]\n[ 0  0 -2  1  0]\n[ 0  1  0 -1  1]\n[ 0 -1  2  0 -2]\n[-1  0 -1  1  0], [ 0  2  0  1 -2]\n[-1  0  1  0  1]\n[ 0 -1  0  0  0]\n[-1  0  0  0  0]\n[ 1 -1  0  0  0], [ 0  0  0  1  0]\n[ 0  0  0 -1  1]\n[ 0  0  0  0 -1]\n[-1  2  0  0  0]\n[ 0 -1  1  0  0], [ 0  1  0 -1  1]\n[-2  0  0  1  0]\n[ 0  0  0  0 -1]\n[ 2 -1  0  0 -2]\n[-1  0  1  1  0], [ 0  0  0  1 -2]\n[ 0  0  1 -1  1]\n[ 0 -1  0  1  0]\n[-1  2 -2  0  0]\n[ 1 -1  0  0  0], [ 0  0  0  0  1]\n[ 0  0  0 -1  1]\n[ 0  0  0  1 -2]\n[ 0  2 -1  0  0]\n[-1 -1  1  0  0], [ 0  0  0  0  1]\n[ 0  0 -1  0  1]\n[ 0  2  0  1 -2]\n[ 0  0 -1  0  0]\n[-1 -1  1  0  0], [ 0  0  0  0  1]\n[ 0  0  1  1 -1]\n[ 0 -1  0  0  0]\n[ 0 -1  0  0  1]\n[-1  2  0 -2  0], [ 0  1  0  0 -2]\n[-1  0  0  2  0]\n[ 0  0  0  1 -1]\n[ 0 -1 -1  0  1]\n[ 1  0  1 -1  0], [ 0  0  0  0  1]\n[ 0  0  1 -2  0]\n[ 0 -1  0  0  2]\n[ 0  1  0  0 -1]\n[-1  0 -1  1  0], [ 0  0  0  0  1]\n[ 0  0 -1  0  1]\n[ 0  2  0  1 -2]\n[ 0  0 -1  0  2]\n[-1 -1  1 -1  0], [ 0  0 -1  0  1]\n[ 0  0  0 -1  1]\n[ 2  0  0  1 -2]\n[ 0  2 -1  0  0]\n[-1 -1  1  0  0], [ 0  0  0  1 -2]\n[ 0  0  1 -1  1]\n[ 0 -1  0  0  0]\n[-1  2  0  0  0]\n[ 1 -1  0  0  0], [ 0 -1  0  0  1]\n[ 2  0  0  1 -2]\n[ 0  0  0  1 -1]\n[ 0 -1 -2  0  2]\n[-1  1  1 -1  0], [ 0 -2  0  0  1]\n[ 1  0  1  1 -1]\n[ 0 -1  0  0  0]\n[ 0 -1  0  0  1]\n[-1  2  0 -2  0], [ 0 -1  0  0  1]\n[ 2  0  0  1 -2]\n[ 0  0  0  0 -1]\n[ 0 -1  0  0  2]\n[-1  1  1 -1  0], [ 0  1  0  0 -2]\n[-1  0  0 -2  2]\n[ 0  0  0 -1  1]\n[ 0  1  1  0 -1]\n[ 1 -1 -1  1  0], [ 0  0  0  0  1]\n[ 0  0  0  1 -2]\n[ 0  0  0  1 -1]\n[ 0 -1 -2  0  2]\n[-1  1  1 -1  0], [ 0  0  0 -1  1]\n[ 0  0  0  1 -2]\n[ 0  0  0  0 -1]\n[ 2 -1  0  0  0]\n[-1  1  1  0  0], [ 0  0 -2  1  0]\n[ 0  0  0 -1  1]\n[ 1  0  0 -1  1]\n[-1  2  2  0 -2]\n[ 0 -1 -1  1  0], [ 0  0 -1  0  1]\n[ 0  0  1 -2  0]\n[ 2 -1  0  0  0]\n[ 0  1  0  0 -1]\n[-1  0  0  1  0], [ 0  2  1 -2 -2]\n[-1  0  0  1  1]\n[-1  0  0  0  2]\n[ 1 -1  0  0  0]\n[ 1 -1 -1  0  0], [ 0  1  0  2 -2]\n[-1  0  0  0  2]\n[ 0  0  0  1 -1]\n[-1  0 -1  0  1]\n[ 1 -1  1 -1  0], [ 0  1  0 -1  1]\n[-2  0  0  1  0]\n[ 0  0  0  1 -1]\n[ 2 -1 -2  0  0]\n[-1  0  1  0  0], [ 0 -1  0  0  1]\n[ 2  0  1 -2  0]\n[ 0 -1  0  2  0]\n[ 0  1 -1  0 -1]\n[-1  0  0  1  0], [ 0  0  0  1  0]\n[ 0  0  1 -1  1]\n[ 0 -1  0  0  1]\n[-1  2  0  0 -2]\n[ 0 -1 -1  1  0], [ 0 -1  0  1  1]\n[ 2  0  1  0 -2]\n[ 0 -1  0  0  0]\n[-1  0  0  0  1]\n[-1  1  0 -1  0], [ 0  0  0  1  0]\n[ 0  0 -2  1  1]\n[ 0  2  0 -1 -1]\n[-1 -2  2  0  0]\n[ 0 -1  1  0  0], [ 0  1  0 -2  1]\n[-2  0  1  2  0]\n[ 0 -1  0  0  0]\n[ 2 -1  0  0 -1]\n[-1  0  0  1  0]]"}︡{"stdout":"\n"}︡
︠8e70e791-346b-40c3-b784-dc3818811d0aos︠
WW = ClusterSeed(['F',4,-1]); WW; WW.show()
︡62d22f78-d5ef-49be-8b04-416ae3c2fb55︡{"stdout":"A seed for a cluster algebra of rank 5 of type ['F', 4, -1]\n"}︡{"once":false,"file":{"show":true,"uuid":"36f7ed72-7aee-4e4c-8a2c-03874feaa234","filename":"/projects/02aac756-d7ee-4d37-9546-ef8d58152220/.sage/temp/compute2-us/30002/tmp_kg9l5n.svg"}}︡{"html":"<div align='center'></div>"}︡
︠347b0085-c5c6-4018-bd9f-7520a6141cc7o︠
WW2 = ClusterSeed(['G',4,]); WW2; WW2.show()
︡7ed81ece-ccd6-44f4-a4fa-0a1fa69d18d6︡{"html": "<span class=\"math\">\\newcommand{\\Bold}[1]{\\mathbf{#1}}\\hbox{A seed for a cluster algebra of rank 4 of type ['W', 4, -2]}</span>"}︡{"html": "<font color='black'><img src='cell://sage0.png'></font>"}︡
︠fab00418-8d4e-4cbb-afc7-834a19dfce00o︠
WW.b_matrix_class()
︡5de9cf7e-c423-468f-bb4b-62bb2ac4aca8︡{"html": "<span class=\"math\">\\newcommand{\\Bold}[1]{\\mathbf{#1}}\\left[\\left(\\begin{array}{rrrr}\n0 & 1 & 1 & -2 \\\\\n-3 & 0 & 0 & 3 \\\\\n-1 & 0 & 0 & 1 \\\\\n2 & -1 & -1 & 0\n\\end{array}\\right), \\left(\\begin{array}{rrrr}\n0 & -1 & 1 & 1 \\\\\n3 & 0 & 0 & -3 \\\\\n-1 & 0 & 0 & 1 \\\\\n-1 & 1 & -1 & 0\n\\end{array}\\right)\\right]</span>"}︡
︠6a4c81fd-c925-4485-9c17-1ec8ce9f372bo︠
WW2.b_matrix_class()
︡966b802a-014b-42ef-b70a-cd3d69be0a1f︡{"html": "<span class=\"math\">\\newcommand{\\Bold}[1]{\\mathbf{#1}}\\left[\\left(\\begin{array}{rrrr}\n0 & 3 & 1 & -2 \\\\\n-1 & 0 & 0 & 1 \\\\\n-1 & 0 & 0 & 1 \\\\\n2 & -3 & -1 & 0\n\\end{array}\\right), \\left(\\begin{array}{rrrr}\n0 & 1 & 0 & -1 \\\\\n-3 & 0 & 1 & 1 \\\\\n0 & -1 & 0 & 1 \\\\\n3 & -1 & -1 & 0\n\\end{array}\\right)\\right]</span>"}︡
︠8259048a-32cd-4394-bd0d-39589811d040o︠
So4 = Matrix([[0,-1,2,-1],[1,0,-3,2],[-2,3,0,-1],[1,-2,1,0]])
︡36c928d5-76ce-459e-9c25-442dac9d0482︡︡
︠5a39bf3a-a09f-4e82-b40c-decf26f7402ao︠
Somos4 = ClusterSeed(So4); Somos4
︡36a17bbb-d4c6-4c99-ac1c-eba49998d8de︡{"html": "<span class=\"math\">\\newcommand{\\Bold}[1]{\\mathbf{#1}}\\hbox{A seed for a cluster algebra of rank 4}</span>"}︡
︠09a69a24-fdff-4f87-afb4-b0b9509fb0a0o︠
Somos4.set_cluster([1,1,1,1])
︡3a577c46-686a-40ea-ab49-8b3017c3b802︡︡
︠a15c3be7-93ed-4c8f-b498-90f36e091120o︠
Somos4.show()
︡507a5e3e-be8e-4ccd-b527-d89ed7950516︡{"html": "<font color='black'><img src='cell://sage0.png'></font>"}︡
︠0604d084-b8e6-4fb7-ae8d-e5123eb3ce85o︠
Somos4.mutate([0,1,2,3]); Somos4.show(); Somos4.cluster()
︡a11c7020-d0b8-45ae-abc7-f24b7f26d113︡{"html": "<font color='black'><img src='cell://sage0.png'></font>"}︡{"html": "<span class=\"math\">\\newcommand{\\Bold}[1]{\\mathbf{#1}}\\left[2, 3, 7, 23\\right]</span>"}︡
︠17b557e8-d61d-44b6-8e48-b94bcdb2992ao︠
Somos4.mutate([0,1,2,3]); Somos4.show(); Somos4.cluster()
︡a885a0e5-26c7-40b9-b988-2bbac6ad613f︡{"html": "<font color='black'><img src='cell://sage0.png'></font>"}︡{"html": "<span class=\"math\">\\newcommand{\\Bold}[1]{\\mathbf{#1}}\\left[59, 314, 1529, 8209\\right]</span>"}︡
︠20ba52df-6114-4ff9-8626-fc9797d43cc9︠
Somos4.mutation_sequence([0,1,2,3,0,1,2,3],return_output='var')
︠011a2b17-6e8d-4870-b81c-6b112eecbb03︠

︠3423e02c-76cb-428d-b701-aa7bddf6ce82s︠
Gr = ClusterSeed(['GR',[4,9]]); Gr
︡506d733f-d545-443a-b0c6-f06cad05fea9︡{"stdout":"A seed for a cluster algebra of rank 12 of type ['GR', [4, 9]]\n"}︡
︠423b259a-6e99-4159-a44b-330d23bcb67fs︠
Gr.show()
︡0ca89251-4552-464c-a657-0debc289860d︡{"once":false,"file":{"show":true,"uuid":"b891d030-25eb-4a1e-aff8-bcef6cfea11a","filename":"/projects/02aac756-d7ee-4d37-9546-ef8d58152220/.sage/temp/compute2-us/30002/tmp_ES99Bw.svg"}}︡{"html":"<div align='center'></div>"}︡
︠30cbede2-0a06-434a-a435-d42651c927fas︠
show(Gr.quiver().digraph())
︡8990abf0-c45e-4eaa-a052-70eafb8d86c9︡{"d3":{"viewer":"graph","data":{"link_distance":50,"link_strength":1,"links":[{"strength":0,"target":4,"color":"#aaa","curve":0,"source":0,"name":""},{"strength":0,"target":0,"color":"#aaa","curve":0,"source":1,"name":""},{"strength":0,"target":2,"color":"#aaa","curve":0,"source":1,"name":""},{"strength":0,"target":6,"color":"#aaa","curve":0,"source":2,"name":""},{"strength":0,"target":2,"color":"#aaa","curve":0,"source":3,"name":""},{"strength":0,"target":5,"color":"#aaa","curve":0,"source":4,"name":""},{"strength":0,"target":1,"color":"#aaa","curve":0,"source":5,"name":""},{"strength":0,"target":9,"color":"#aaa","curve":0,"source":5,"name":""},{"strength":0,"target":5,"color":"#aaa","curve":0,"source":6,"name":""},{"strength":0,"target":7,"color":"#aaa","curve":0,"source":6,"name":""},{"strength":0,"target":3,"color":"#aaa","curve":0,"source":7,"name":""},{"strength":0,"target":11,"color":"#aaa","curve":0,"source":7,"name":""},{"strength":0,"target":4,"color":"#aaa","curve":0,"source":8,"name":""},{"strength":0,"target":8,"color":"#aaa","curve":0,"source":9,"name":""},{"strength":0,"target":10,"color":"#aaa","curve":0,"source":9,"name":""},{"strength":0,"target":6,"color":"#aaa","curve":0,"source":10,"name":""},{"strength":0,"target":10,"color":"#aaa","curve":0,"source":11,"name":""}],"pos":[],"height":null,"edge_thickness":2,"loops":[],"edge_labels":false,"vertex_size":7,"vertex_labels":true,"directed":true,"gravity":0.04,"width":null,"charge":-120,"nodes":[{"group":"0","name":"0"},{"group":"0","name":"1"},{"group":"0","name":"2"},{"group":"0","name":"3"},{"group":"0","name":"4"},{"group":"0","name":"5"},{"group":"0","name":"6"},{"group":"0","name":"7"},{"group":"0","name":"8"},{"group":"0","name":"9"},{"group":"0","name":"10"},{"group":"0","name":"11"}]}}}︡{"html":"<div align='center'></div>"}︡
︠e8709d18-d74a-4bbc-8dcd-8e4141c4e48d︠









